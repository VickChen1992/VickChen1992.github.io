<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Vick&#39;s Blog</title>
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="VickChen.win/"/>
  <updated>2020-07-26T08:15:56.789Z</updated>
  <id>VickChen.win/</id>
  
  <author>
    <name>Vick</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>.NET Core中间件</title>
    <link href="VickChen.win/2020/202006210014/"/>
    <id>VickChen.win/2020/202006210014/</id>
    <published>2020-06-20T16:14:29.000Z</published>
    <updated>2020-07-26T08:15:56.789Z</updated>
    
    <content type="html"><![CDATA[<p>ASP.NET Core 中 HTTP 管道使用中间件组合处理的方式。换句人话来说，对于写代码的人而言，一切皆中间件。业务逻辑/数据访问/等等一切都需要以中间件的方式来呈现。 </p>
<a id="more"></a>
<h2 id="什么是中间件"><a href="#什么是中间件" class="headerlink" title="什么是中间件"></a>什么是中间件</h2><p>我们都知道，任何的一个web框架都是把Http请求封装成一个管道，每一次的请求都是经过管道的一系列操作，最终才会到达我们写的代码中。而中间件就是用于组成应用程序管道来处理请求和响应的组件。管道内的每一个组件都可以选择是否将请求转交给下一个组件，并在管道中调用下一个组件之前和之后执行某些操作。请求委托被用来建立请求管道，请求委托处理每一个Http请求。</p>
<p>中间件可以认为有两个基本的职责：</p>
<ol>
<li>选择是否将请求传递给管道中的下一个中间件。</li>
<li>可以在管道中的下一个中间件前后执行一些工作。</li>
</ol>
<p>请求委托通过使用<code>IApplicationBuilder</code>类型的<code>Run</code>、<code>Map</code>以及<code>Use</code>扩展方法来配置，并在<code>Startup</code>类中传给<code>Configure</code>方法。每个单独的请求委托都可以被指定为一个内嵌匿名方法，或其定义在一个可重用的类中。这些可以重用的类被称作 <code>中间件</code>或<code>中间件组件</code>。每个位于请求管道内的中间件组件负责调用管道中下一个组件，或适时短路调用链。中间件是一个典型的<code>AOP</code>应用。</p>
<p>看完上面的介绍，可能还是不太了解中间件在程序中到底是什么？那么就从大家熟悉的<code>Startup</code>类里<code>Configure</code>方法中的那个<code>IApplicationBuilder</code>说起</p>
<p><code>IApplicationBuilder</code>，应用构建者，听这个名字就能感受它的核心地位，ASP.NET Core应用就是依赖它构建出来，看看它的定义：</p>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title">IApplicationBuilder</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//...省略部分代码...</span></span><br><span class="line">    <span class="function">IApplicationBuilder <span class="title">Use</span>(<span class="params">Func&lt;RequestDelegate, RequestDelegate&gt; middleware</span>)</span>;</span><br><span class="line">    <span class="function">RequestDelegate <span class="title">Build</span>(<span class="params"></span>)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>Use</code>方法用来把中间件添加到应用管道中，此时我们已经看到中间件的真面目了，原来是一个委托，输入参数是<code>RequestDelegate</code>，返回也是<code>RequestDelegate</code>，其实<code>RequestDelegate</code>还是个委托，如下：</p>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">delegate</span> Task <span class="title">RequestDelegate</span>(<span class="params">HttpContext context</span>)</span>;</span><br></pre></td></tr></table></figure>
<p>还记得中间件是干嘛的吗？是用来处理Http请求和响应的，即对<code>HttpContext</code>的处理，这里我们可以看出来原来中间件的业务逻辑就是封装在<code>RequestDelegate</code>里面。</p>
<h2 id="Use-Run-和-Map"><a href="#Use-Run-和-Map" class="headerlink" title="Use, Run, 和 Map"></a>Use, Run, 和 Map</h2><p>.NET Core 中间件的配置方法分别是：<code>Run()</code>，<code>Use()</code>，<code>Map()</code>：</p>
<ul>
<li><strong>Run()</strong>，使用此方法调用中间件的时候，可以使管道短路，会直接返回一个响应，所以后续的中间件将不再被执行。</li>
<li><strong>Use()</strong>，此方法是一个约定，会对请求做一些工作或处理，例如添加一些请求的上下文数据，有时候甚至什么也不做，直接把请求交给下一个中间件。</li>
<li><strong>Map()</strong>，它会把请求重新路由到其它的中间件路径上去。</li>
</ul>
<h2 id="使用-IApplicationBuilder-创建中间件管道"><a href="#使用-IApplicationBuilder-创建中间件管道" class="headerlink" title="使用 IApplicationBuilder 创建中间件管道"></a>使用 IApplicationBuilder 创建中间件管道</h2><p>ASP.NET Core 请求管道包含一系列请求委托，依次调用。 下图演示了这一概念。 沿黑色箭头执行。</p>
<p><img src="https://docs.microsoft.com/zh-cn/aspnet/core/fundamentals/middleware/index/_static/request-delegate-pipeline.png?view=aspnetcore-3.1" alt="请求处理模式显示请求到达、通过三个中间件进行处理以及响应离开应用。"></p>
<p>每个委托均可在下一个委托前后执行操作。 应尽早在管道中调用异常处理委托，这样它们就能捕获在管道的后期阶段发生的异常。</p>
<p>尽可能简单的 ASP.NET Core 应用设置了处理所有请求的单个请求委托。 这种情况不包括实际请求管道。 调用单个匿名函数以响应每个 HTTP 请求。</p>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">Startup</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Configure</span>(<span class="params">IApplicationBuilder app</span>)</span></span><br><span class="line"><span class="function"></span>    &#123;</span><br><span class="line">        app.Run(<span class="keyword">async</span> context =&gt;</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">await</span> context.Response.WriteAsync(<span class="string">"Hello, World!"</span>);</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>第一个 <a href="https://docs.microsoft.com/zh-cn/dotnet/api/microsoft.aspnetcore.builder.runextensions.run" target="_blank" rel="noopener">Run</a> 委托终止了管道。</p>
<p>用 <a href="https://docs.microsoft.com/zh-cn/dotnet/api/microsoft.aspnetcore.builder.useextensions.use" target="_blank" rel="noopener">Use</a> 将多个请求委托链接在一起。 <code>next</code> 参数表示管道中的下一个委托。 可通过不调用 next 参数使管道短路。 通常可在下一个委托前后执行操作，如以下示例所示：</p>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">Startup</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Configure</span>(<span class="params">IApplicationBuilder app</span>)</span></span><br><span class="line"><span class="function"></span>    &#123;</span><br><span class="line">        app.Use(<span class="keyword">async</span> (context, next) =&gt;</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">// Do work that doesn't write to the Response.</span></span><br><span class="line">            <span class="keyword">await</span> next.Invoke();</span><br><span class="line">            <span class="comment">// Do logging or other work that doesn't write to the Response.</span></span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        app.Run(<span class="keyword">async</span> context =&gt;</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">await</span> context.Response.WriteAsync(<span class="string">"Hello from 2nd delegate."</span>);</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>当委托不将请求传递给下一个委托时，它被称为“让请求管道短路”。 通常需要短路，因为这样可以避免不必要的工作。 例如，<a href="https://docs.microsoft.com/zh-cn/aspnet/core/fundamentals/static-files?view=aspnetcore-2.1" target="_blank" rel="noopener">静态文件中间件</a>可以处理对静态文件的请求，并让管道的其余部分短路，从而起到终端中间件的作用。 如果中间件添加到管道中，且位于终止进一步处理的中间件前，它们仍处理 <code>next.Invoke</code> 语句后面的代码。 不过，请参阅下面有关尝试对已发送的响应执行写入操作的警告。</p>
<p><strong>在向客户端发送响应后，请勿调用 <code>next.Invoke</code>。</strong> 响应启动后，针对 <a href="https://docs.microsoft.com/zh-cn/dotnet/api/microsoft.aspnetcore.http.httpresponse" target="_blank" rel="noopener">HttpResponse</a> 的更改将引发异常。 例如，设置标头和状态代码更改将引发异常。 调用 <code>next</code> 后写入响应正文：</p>
<ul>
<li>可能导致违反协议。 例如，写入的长度超过规定的 <code>Content-Length</code>。</li>
<li>可能损坏正文格式。 例如，向 CSS 文件中写入 HTML 页脚。</li>
</ul>
<p><a href="https://docs.microsoft.com/zh-cn/dotnet/api/microsoft.aspnetcore.http.httpresponse.hasstarted" target="_blank" rel="noopener">HasStarted</a> 是一个有用的提示，指示是否已发送标头或已写入正文。</p>
<h2 id="中间件顺序"><a href="#中间件顺序" class="headerlink" title="中间件顺序"></a>中间件顺序</h2><p>向 <code>Startup.Configure</code> 方法添加中间件组件的顺序定义了针对请求调用这些组件的顺序，以及响应的相反顺序。 此顺序对于安全性、性能和功能至关重要。</p>
<p>下面的 <code>Startup.Configure</code> 方法按照建议的顺序增加与安全相关的中间件组件：</p>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Configure</span>(<span class="params">IApplicationBuilder app, IHostingEnvironment env</span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (env.IsDevelopment())</span><br><span class="line">    &#123;</span><br><span class="line">        app.UseDeveloperExceptionPage();</span><br><span class="line">        app.UseDatabaseErrorPage();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        app.UseExceptionHandler(<span class="string">"/Home/Error"</span>);</span><br><span class="line">        app.UseHsts();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    app.UseHttpsRedirection();</span><br><span class="line">    app.UseStaticFiles();</span><br><span class="line">    app.UseCookiePolicy();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// app.UseRequestLocalization();</span></span><br><span class="line">    <span class="comment">// app.UseCors();</span></span><br><span class="line"></span><br><span class="line">    app.UseAuthentication();</span><br><span class="line">    <span class="comment">// app.UseSession();</span></span><br><span class="line"></span><br><span class="line">    app.UseMvc(routes =&gt;</span><br><span class="line">    &#123;</span><br><span class="line">        routes.MapRoute(</span><br><span class="line">            name: <span class="string">"default"</span>,</span><br><span class="line">            template: <span class="string">"&#123;controller=Home&#125;/&#123;action=Index&#125;/&#123;id?&#125;"</span>);</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在上述代码中：</p>
<ul>
<li>在使用<a href="https://docs.microsoft.com/zh-cn/aspnet/core/security/authentication/identity?view=aspnetcore-2.1" target="_blank" rel="noopener">单个用户帐户</a>创建新的 Web 应用时未添加的中间件已被注释掉。</li>
<li>并非所有中间件都需要准确按照此顺序运行，但许多中间件必须遵循这个顺序。 例如，<code>UseCors</code> 和 <code>UseAuthentication</code> 必须按照上述顺序运行。</li>
</ul>
<p>以下 <code>Startup.Configure</code> 方法将为常见应用方案添加中间件组件：</p>
<ol>
<li>异常/错误处理<ul>
<li>当应用在开发环境中运行时：<ul>
<li>开发人员异常页中间件 (<a href="https://docs.microsoft.com/zh-cn/dotnet/api/microsoft.aspnetcore.builder.developerexceptionpageextensions.usedeveloperexceptionpage" target="_blank" rel="noopener">UseDeveloperExceptionPage</a>) 报告应用运行时错误。</li>
<li>数据库错误页中间件 (<code>Microsoft.AspNetCore.Builder.DatabaseErrorPageExtensions.UseDatabaseErrorPage</code>) 报告数据库运行时错误。</li>
</ul>
</li>
<li>当应用在生产环境中运行时：<ul>
<li>异常处理程序中间件 (<a href="https://docs.microsoft.com/zh-cn/dotnet/api/microsoft.aspnetcore.builder.exceptionhandlerextensions.useexceptionhandler" target="_blank" rel="noopener">UseExceptionHandler</a>) 捕获以下中间件中引发的异常。</li>
<li>HTTP 严格传输安全协议 (HSTS) 中间件 (<a href="https://docs.microsoft.com/zh-cn/dotnet/api/microsoft.aspnetcore.builder.hstsbuilderextensions.usehsts" target="_blank" rel="noopener">UseHsts</a>) 添加 <code>Strict-Transport-Security</code> 标头。</li>
</ul>
</li>
</ul>
</li>
<li>HTTPS 重定向中间件 (<a href="https://docs.microsoft.com/zh-cn/dotnet/api/microsoft.aspnetcore.builder.httpspolicybuilderextensions.usehttpsredirection" target="_blank" rel="noopener">UseHttpsRedirection</a>) 将 HTTP 请求重定向到 HTTPS。</li>
<li>静态文件中间件 (<a href="https://docs.microsoft.com/zh-cn/dotnet/api/microsoft.aspnetcore.builder.staticfileextensions.usestaticfiles" target="_blank" rel="noopener">UseStaticFiles</a>) 返回静态文件，并简化进一步请求处理。</li>
<li>Cookie 策略中间件 (<a href="https://docs.microsoft.com/zh-cn/dotnet/api/microsoft.aspnetcore.builder.cookiepolicyappbuilderextensions.usecookiepolicy" target="_blank" rel="noopener">UseCookiePolicy</a>) 使应用符合欧盟一般数据保护条例 (GDPR) 规定。</li>
<li>身份验证中间件 (<a href="https://docs.microsoft.com/zh-cn/dotnet/api/microsoft.aspnetcore.builder.authappbuilderextensions.useauthentication" target="_blank" rel="noopener">UseAuthentication</a>) 尝试对用户进行身份验证，然后才会允许用户访问安全资源。</li>
<li>会话中间件 (<a href="https://docs.microsoft.com/zh-cn/dotnet/api/microsoft.aspnetcore.builder.sessionmiddlewareextensions.usesession" target="_blank" rel="noopener">UseSession</a>) 建立和维护会话状态。 如果应用使用会话状态，请在 Cookie 策略中间件之后和 MVC 中间件之前调用会话中间件。</li>
<li>MVC (<a href="https://docs.microsoft.com/zh-cn/dotnet/api/microsoft.aspnetcore.builder.mvcapplicationbuilderextensions.usemvc" target="_blank" rel="noopener">UseMvc</a>) 将 MVC 添加到请求管道。</li>
</ol>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Configure</span>(<span class="params">IApplicationBuilder app, IHostingEnvironment env</span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (env.IsDevelopment())</span><br><span class="line">    &#123;</span><br><span class="line">        app.UseDeveloperExceptionPage();</span><br><span class="line">        app.UseDatabaseErrorPage();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        app.UseExceptionHandler(<span class="string">"/Error"</span>);</span><br><span class="line">        app.UseHsts();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    app.UseHttpsRedirection();</span><br><span class="line">    app.UseStaticFiles();</span><br><span class="line">    app.UseCookiePolicy();</span><br><span class="line">    app.UseAuthentication();</span><br><span class="line">    app.UseSession();</span><br><span class="line">    app.UseMvc();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><a href="https://docs.microsoft.com/zh-cn/dotnet/api/microsoft.aspnetcore.builder.exceptionhandlerextensions.useexceptionhandler" target="_blank" rel="noopener">UseExceptionHandler</a> 是添加到管道的第一个中间件组件。 因此，异常处理程序中间件可捕获稍后调用中发生的任何异常。</p>
<p>尽早在管道中调用静态文件中间件，以便它可以处理请求并使其短路，而无需通过剩余组件。 静态文件中间件不提供授权检查。 可公开访问由静态文件中间件服务的任何文件，包括 wwwroot 下的文件。</p>
<p>如果静态文件中间件未处理请求，则请求将被传递给执行身份验证的身份验证中间件 (<a href="https://docs.microsoft.com/zh-cn/dotnet/api/microsoft.aspnetcore.builder.authappbuilderextensions.useauthentication" target="_blank" rel="noopener">UseAuthentication</a>)。 身份验证不使未经身份验证的请求短路。 虽然身份验证中间件对请求进行身份验证，但仅在 MVC 选择特定 Razor Page 或 MVC 控制器和操作后，才发生授权（和拒绝）。</p>
<p>以下示例演示中间件排序，其中静态文件的请求在响应压缩中间件前由静态文件中间件进行处理。 使用此中间件顺序不压缩静态文件。 可以压缩来自 <a href="https://docs.microsoft.com/zh-cn/dotnet/api/microsoft.aspnetcore.builder.mvcapplicationbuilderextensions.usemvcwithdefaultroute" target="_blank" rel="noopener">UseMvcWithDefaultRoute</a> 的 MVC 响应。</p>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Configure</span>(<span class="params">IApplicationBuilder app</span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// Static files aren't compressed by Static File Middleware.</span></span><br><span class="line">    app.UseStaticFiles();</span><br><span class="line"></span><br><span class="line">    app.UseResponseCompression();</span><br><span class="line"></span><br><span class="line">    app.UseMvcWithDefaultRoute();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="内置中间件"><a href="#内置中间件" class="headerlink" title="内置中间件"></a>内置中间件</h2><p>.NET Core 附带以下中间件组件。 “顺序”列提供备注，以说明中间件在请求处理管道中的放置，以及中间件可能会终止请求处理的条件。 如果中间件让请求处理管道短路，并阻止下游中间件进一步处理请求，它被称为“终端中间件”。</p>
<table>
<thead>
<tr>
<th style="text-align:left">中间件</th>
<th style="text-align:left">描述</th>
<th style="text-align:left">顺序</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left"><a href="https://docs.microsoft.com/zh-cn/aspnet/core/security/authentication/identity?view=aspnetcore-2.1" target="_blank" rel="noopener">身份验证</a></td>
<td style="text-align:left">提供身份验证支持。</td>
<td style="text-align:left">在需要 <code>HttpContext.User</code> 之前。 OAuth 回叫的终端。</td>
</tr>
<tr>
<td style="text-align:left"><a href="https://docs.microsoft.com/zh-cn/aspnet/core/security/gdpr?view=aspnetcore-2.1" target="_blank" rel="noopener">Cookie 策略</a></td>
<td style="text-align:left">跟踪用户是否同意存储个人信息，并强制实施 cookie 字段（如 <code>secure</code> 和 <code>SameSite</code>）的最低标准。</td>
<td style="text-align:left">在发出 cookie 的中间件之前。 示例：身份验证、会话、MVC (TempData)。</td>
</tr>
<tr>
<td style="text-align:left"><a href="https://docs.microsoft.com/zh-cn/aspnet/core/security/cors?view=aspnetcore-2.1" target="_blank" rel="noopener">CORS</a></td>
<td style="text-align:left">配置跨域资源共享。</td>
<td style="text-align:left">在使用 CORS 的组件之前。</td>
</tr>
<tr>
<td style="text-align:left"><a href="https://docs.microsoft.com/zh-cn/aspnet/core/fundamentals/error-handling?view=aspnetcore-2.1" target="_blank" rel="noopener">诊断</a></td>
<td style="text-align:left">提供新应用的开发人员异常页、异常处理、状态代码页和默认网页的几个单独的中间件。</td>
<td style="text-align:left">在生成错误的组件之前。 异常终端或为新应用提供默认网页的终端。</td>
</tr>
<tr>
<td style="text-align:left"><a href="https://docs.microsoft.com/zh-cn/aspnet/core/host-and-deploy/proxy-load-balancer?view=aspnetcore-2.1" target="_blank" rel="noopener">转接头</a></td>
<td style="text-align:left">将代理标头转发到当前请求。</td>
<td style="text-align:left">在使用已更新字段的组件之前。 示例：方案、主机、客户端 IP、方法。</td>
</tr>
<tr>
<td style="text-align:left"><a href="https://docs.microsoft.com/zh-cn/aspnet/core/host-and-deploy/health-checks?view=aspnetcore-2.1" target="_blank" rel="noopener">运行状况检查</a></td>
<td style="text-align:left">检查 ASP.NET Core 应用及其依赖项的运行状况，如检查数据库可用性。</td>
<td style="text-align:left">如果请求与运行状况检查终结点匹配，则为终端。</td>
</tr>
<tr>
<td style="text-align:left"><a href="https://docs.microsoft.com/zh-cn/dotnet/api/microsoft.aspnetcore.builder.httpmethodoverrideextensions" target="_blank" rel="noopener">HTTP 方法重写</a></td>
<td style="text-align:left">允许传入 POST 请求重写方法。</td>
<td style="text-align:left">在使用已更新方法的组件之前。</td>
</tr>
<tr>
<td style="text-align:left"><a href="https://docs.microsoft.com/zh-cn/aspnet/core/security/enforcing-ssl?view=aspnetcore-2.1#require-https" target="_blank" rel="noopener">HTTPS 重定向</a></td>
<td style="text-align:left">将所有 HTTP 请求重定向到 HTTPS。</td>
<td style="text-align:left">在使用 URL 的组件之前。</td>
</tr>
<tr>
<td style="text-align:left"><a href="https://docs.microsoft.com/zh-cn/aspnet/core/security/enforcing-ssl?view=aspnetcore-2.1#http-strict-transport-security-protocol-hsts" target="_blank" rel="noopener">HTTP 严格传输安全协议 (HSTS)</a></td>
<td style="text-align:left">添加特殊响应标头的安全增强中间件。</td>
<td style="text-align:left">在发送响应之前，修改请求的组件之后。 示例：转接头、URL 重写。</td>
</tr>
<tr>
<td style="text-align:left"><a href="https://docs.microsoft.com/zh-cn/aspnet/core/mvc/overview?view=aspnetcore-2.1" target="_blank" rel="noopener">MVC</a></td>
<td style="text-align:left">用 MVC/Razor Pages 处理请求。</td>
<td style="text-align:left">如果请求与路由匹配，则为终端。</td>
</tr>
<tr>
<td style="text-align:left"><a href="https://docs.microsoft.com/zh-cn/aspnet/core/fundamentals/owin?view=aspnetcore-2.1" target="_blank" rel="noopener">OWIN</a></td>
<td style="text-align:left">与基于 OWIN 的应用、服务器和中间件进行互操作。</td>
<td style="text-align:left">如果 OWIN 中间件处理完请求，则为终端。</td>
</tr>
<tr>
<td style="text-align:left"><a href="https://docs.microsoft.com/zh-cn/aspnet/core/performance/caching/middleware?view=aspnetcore-2.1" target="_blank" rel="noopener">响应缓存</a></td>
<td style="text-align:left">提供对缓存响应的支持。</td>
<td style="text-align:left">在需要缓存的组件之前。</td>
</tr>
<tr>
<td style="text-align:left"><a href="https://docs.microsoft.com/zh-cn/aspnet/core/performance/response-compression?view=aspnetcore-2.1" target="_blank" rel="noopener">响应压缩</a></td>
<td style="text-align:left">提供对压缩响应的支持。</td>
<td style="text-align:left">在需要压缩的组件之前。</td>
</tr>
<tr>
<td style="text-align:left"><a href="https://docs.microsoft.com/zh-cn/aspnet/core/fundamentals/localization?view=aspnetcore-2.1" target="_blank" rel="noopener">请求本地化</a></td>
<td style="text-align:left">提供本地化支持。</td>
<td style="text-align:left">在对本地化敏感的组件之前。</td>
</tr>
<tr>
<td style="text-align:left"><a href="https://docs.microsoft.com/zh-cn/aspnet/core/fundamentals/routing?view=aspnetcore-2.1" target="_blank" rel="noopener">终结点路由</a></td>
<td style="text-align:left">定义和约束请求路由。</td>
<td style="text-align:left">用于匹配路由的终端。</td>
</tr>
<tr>
<td style="text-align:left"><a href="https://docs.microsoft.com/zh-cn/aspnet/core/fundamentals/app-state?view=aspnetcore-2.1" target="_blank" rel="noopener">会话</a></td>
<td style="text-align:left">提供对管理用户会话的支持。</td>
<td style="text-align:left">在需要会话的组件之前。</td>
</tr>
<tr>
<td style="text-align:left"><a href="https://docs.microsoft.com/zh-cn/aspnet/core/fundamentals/static-files?view=aspnetcore-2.1" target="_blank" rel="noopener">静态文件</a></td>
<td style="text-align:left">为提供静态文件和目录浏览提供支持。</td>
<td style="text-align:left">如果请求与文件匹配，则为终端。</td>
</tr>
<tr>
<td style="text-align:left"><a href="https://docs.microsoft.com/zh-cn/aspnet/core/fundamentals/url-rewriting?view=aspnetcore-2.1" target="_blank" rel="noopener">URL 重写</a></td>
<td style="text-align:left">提供对重写 URL 和重定向请求的支持。</td>
<td style="text-align:left">在使用 URL 的组件之前。</td>
</tr>
<tr>
<td style="text-align:left"><a href="https://docs.microsoft.com/zh-cn/aspnet/core/fundamentals/websockets?view=aspnetcore-2.1" target="_blank" rel="noopener">WebSockets</a></td>
<td style="text-align:left">启用 WebSockets 协议。</td>
<td style="text-align:left">在接受 WebSocket 请求所需的组件之前。</td>
</tr>
</tbody>
</table>
<p><em>部分转自 - <a href="https://docs.microsoft.com/zh-cn/aspnet/core/fundamentals/middleware/?view=aspnetcore-3.1" target="_blank" rel="noopener">ASP.NET Core 文档</a></em></p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;ASP.NET Core 中 HTTP 管道使用中间件组合处理的方式。换句人话来说，对于写代码的人而言，一切皆中间件。业务逻辑/数据访问/等等一切都需要以中间件的方式来呈现。 &lt;/p&gt;
    
    </summary>
    
      <category term="技术" scheme="VickChen.win/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="CSharp" scheme="VickChen.win/tags/CSharp/"/>
    
      <category term=".Net Core" scheme="VickChen.win/tags/Net-Core/"/>
    
      <category term="中间件" scheme="VickChen.win/tags/%E4%B8%AD%E9%97%B4%E4%BB%B6/"/>
    
  </entry>
  
  <entry>
    <title>设计模式之行为模式</title>
    <link href="VickChen.win/2020/202005192357/"/>
    <id>VickChen.win/2020/202005192357/</id>
    <published>2020-04-11T15:01:22.000Z</published>
    <updated>2020-07-23T11:49:30.006Z</updated>
    
    <content type="html"><![CDATA[<p>行为型模式共有十一种：策略模式、模板方法模式、观察者模式、迭代器模式、责任链模式、命令模式、备忘录模式、状态模式、访问者模式、中介者模式、解释器模式。</p>
<ul>
<li>策略模式 ：封装不同的算法，算法之间能互相替换</li>
<li>状态模式 ：根据不同的状态做出不同的行为</li>
<li>责任链模式 ：将事件沿着链去处理</li>
<li>观察者模式 ：状态发生改变时通知观察者，一对多的关系</li>
<li>模板方法模式 ：定义一套流程模板，根据需要实现模板中的操作</li>
<li>迭代器模式 ：提供一种方法顺序访问一个聚合对象中的各个元素</li>
<li>备忘录模式 ：保存对象的状态，在需要时进行恢复</li>
<li>访问者模式 ：稳定数据结构中，定义新的操作行为</li>
<li>中介者模式 ：将网状结构转变为星型结构，所有行为都通过中介</li>
<li>解释器模式 ：定义语法，并对其进行解释</li>
<li>命令模式 ：将请求封装成命令，并记录下来，能够撤销与重做</li>
</ul>
<a id="more"></a>
<p>行为型模式是对在不同对象之间划分责任和算法的抽象化，这类模式负责对象间的高效沟通和职责委派。行为模式不仅仅关于类和对象，还关于它们之间的相互作用。它包括两种类型:</p>
<ul>
<li>类的行为模式：使用继承关系在几个类之间分配行为。</li>
<li>对象的行为模式：使用对象聚合的方式来分配行为。</li>
</ul>
<h2 id="策略模式"><a href="#策略模式" class="headerlink" title="策略模式"></a>策略模式</h2><p>策略模式是对算法的包装，是把使用算法的责任和算法本身分割开，委派给不同的对象负责。策略模式通常把一系列的算法包装到一系列的策略类里面。用一句话慨括策略模式就是——“将每个算法封装到不同的策略类中，使得它们可以互换”。</p>
<p>在现实生活中，中国的所得税，分为企业所得税、外商投资企业或外商企业所得税和个人所得税，针对于这3种所得税，每种所计算的方式不同，个人所得税有个人所得税的计算方式，而企业所得税有其对应计算方式。如果不采用策略模式来实现这样一个需求的话，我们会定义一个所得税类，该类有一个属性来标识所得税的类型，并且有一个计算税收的<code>CalculateTax()</code>方法，在该方法体内需要对税收类型进行判断，通过<code>if-else</code>语句来针对不同的税收类型来计算其所得税。这样的实现确实可以解决这个场景，但是这样的设计不利于扩展，如果系统后期需要增加一种所得税时，此时不得不回去修改<code>CalculateTax</code>方法来多添加一个判断语句，这样显然违背了开闭原则。此时，我们可以考虑使用策略模式来解决这个问题，既然税收方法是这个场景中的变化部分，此时自然可以想到对税收方法进行抽象，这也是策略模式实现的精髓所在。</p>
<p><img src="https://gitee.com/vickchen/blogImgs/raw/master/img/%E7%AD%96%E7%95%A5.png" alt></p>
<h3 id="实现方法"><a href="#实现方法" class="headerlink" title="实现方法"></a>实现方法</h3><ol>
<li>从上下文类中找出修改频率较高的算法 （也可能是用于在运行时选择某个算法变体的复杂条件运算符）。</li>
<li>声明该算法所有变体的通用策略接口。</li>
<li>将算法逐一抽取到各自的类中， 它们都必须实现策略接口。</li>
<li>在上下文类中添加一个成员变量用于保存对于策略对象的引用。 然后提供设置器以修改该成员变量。 上下文仅可通过策略接口同策略对象进行交互， 如有需要还可定义一个接口来让策略访问其数据。</li>
<li>客户端必须将上下文类与相应策略进行关联， 使上下文可以预期的方式完成其主要工作。</li>
</ol>
<h3 id="适用场景"><a href="#适用场景" class="headerlink" title="适用场景"></a>适用场景</h3><ul>
<li>当你想使用对象中各种不同的算法变体， 并希望能在运行时切换算法时， 可使用策略模式。</li>
<li>当你有许多仅在执行某些行为时略有不同的相似类时， 可使用策略模式。</li>
<li>如果算法在上下文的逻辑中不是特别重要， 使用该模式能将类的业务逻辑与其算法实现细节隔离开来。</li>
<li>当类中使用了复杂条件运算符以在同一算法的不同变体中切换时， 可使用该模式。</li>
</ul>
<h2 id="状态模式"><a href="#状态模式" class="headerlink" title="状态模式"></a>状态模式</h2><p>状态模式是一种行为设计模式， 让你能在一个对象的内部状态变化时改变其行为， 使其看上去就像改变了自身所属的类一样。</p>
<p>每个对象都有其对应的状态，而每个状态又对应一些相应的行为，如果某个对象有多个状态时，那么就会对应很多的行为。那么对这些状态的判断和根据状态完成的行为，就会导致多重条件语句，并且如果添加一种新的状态时，需要更改之前现有的代码。这样的设计显然违背了开闭原则，状态模式正是用来解决这样的问题的。</p>
<p><img src="https://gitee.com/vickchen/blogImgs/raw/master/img/%E7%8A%B6%E6%80%81.png" alt></p>
<h3 id="实现方法-1"><a href="#实现方法-1" class="headerlink" title="实现方法"></a>实现方法</h3><ol>
<li><p>确定哪些类是上下文。 它可能是包含依赖于状态的代码的已有类； 如果特定于状态的代码分散在多个类中， 那么它可能是一个新的类。</p>
</li>
<li><p>声明状态接口。 虽然你可能会需要完全复制上下文中声明的所有方法， 但最好是仅把关注点放在那些可能包含特定于状态的行为的方法上。</p>
</li>
<li><p>为每个实际状态创建一个继承于状态接口的类。 然后检查上下文中的方法并将与特定状态相关的所有代码抽取到新建的类中。</p>
<p>在将代码移动到状态类的过程中， 你可能会发现它依赖于上下文中的一些私有成员。 你可以采用以下几种变通方式：</p>
<ul>
<li>将这些成员变量或方法设为公有。</li>
<li>将需要抽取的上下文行为更改为上下文中的公有方法， 然后在状态类中调用。 这种方式简陋却便捷， 你可以稍后再对其进行修补。</li>
<li>将状态类嵌套在上下文类中。 这种方式需要你所使用的编程语言支持嵌套类。</li>
</ul>
</li>
<li><p>在上下文类中添加一个状态接口类型的引用成员变量， 以及一个用于修改该成员变量值的公有设置器。</p>
</li>
<li><p>再次检查上下文中的方法， 将空的条件语句替换为相应的状态对象方法。</p>
</li>
<li><p>为切换上下文状态， 你需要创建某个状态类实例并将其传递给上下文。 你可以在上下文、 各种状态或客户端中完成这项工作。 无论在何处完成这项工作， 该类都将依赖于其所实例化的具体类。</p>
</li>
</ol>
<h3 id="适用场景-1"><a href="#适用场景-1" class="headerlink" title="适用场景"></a>适用场景</h3><ul>
<li>如果对象需要根据自身当前状态进行不同行为， 同时状态的数量非常多且与状态相关的代码会频繁变更的话， 可使用状态模式。</li>
<li>如果某个类需要根据成员变量的当前值改变自身行为， 从而需要使用大量的条件语句时， 可使用该模式。</li>
<li>当相似状态和基于条件的状态机转换中存在许多重复代码时， 可使用状态模式。</li>
</ul>
<h2 id="责任链模式"><a href="#责任链模式" class="headerlink" title="责任链模式"></a>责任链模式</h2><p>责任链模式允许你将请求沿着处理者链进行发送。 收到请求后， 每个处理者均可对请求进行处理， 或将其传递给链上的下个处理者。</p>
<p>某个请求需要多个对象进行处理，从而避免请求的发送者和接收之间的耦合关系。将这些对象连成一条链子，并沿着这条链子传递该请求，直到有对象处理它为止。<img src="https://gitee.com/vickchen/blogImgs/raw/master/img/%E8%B4%A3%E4%BB%BB%E9%93%BE.png" alt></p>
<h3 id="实现方法-2"><a href="#实现方法-2" class="headerlink" title="实现方法"></a>实现方法</h3><ol>
<li><p>声明处理者接口并描述请求处理方法的签名。</p>
<p>确定客户端如何将请求数据传递给方法。 最灵活的方式是将请求转换为对象， 然后将其以参数的形式传递给处理函数。</p>
</li>
<li><p>为了在具体处理者中消除重复的样本代码， 你可以根据处理者接口创建抽象处理者基类。</p>
<p>该类需要有一个成员变量来存储指向链上下个处理者的引用。 你可以将其设置为不可变类。 但如果你打算在运行时对链进行改变， 则需要定义一个设定方法来修改引用成员变量的值。</p>
<p>为了使用方便， 你还可以实现处理方法的默认行为。 如果还有剩余对象， 该方法会将请求传递给下个对象。 具体处理者还能够通过调用父对象的方法来使用这一行为。</p>
</li>
<li><p>依次创建具体处理者子类并实现其处理方法。 每个处理者在接收到请求后都必须做出两个决定：</p>
<ul>
<li>是否自行处理这个请求。</li>
<li>是否将该请求沿着链进行传递。</li>
</ul>
</li>
<li><p>客户端可以自行组装链， 或者从其他对象处获得预先组装好的链。 在后一种情况下， 你必须实现工厂类以根据配置或环境设置来创建链。</p>
</li>
<li><p>客户端可以触发链中的任意处理者， 而不仅仅是第一个。 请求将通过链进行传递， 直至某个处理者拒绝继续传递， 或者请求到达链尾。</p>
</li>
<li><p>由于链的动态性， 客户端需要准备好处理以下情况：</p>
<ul>
<li>链中可能只有单个链接。</li>
<li>部分请求可能无法到达链尾。</li>
<li>其他请求可能直到链尾都未被处理。</li>
</ul>
</li>
</ol>
<h3 id="适用场景-2"><a href="#适用场景-2" class="headerlink" title="适用场景"></a>适用场景</h3><ul>
<li>当程序需要使用不同方式处理不同种类请求， 而且请求类型和顺序预先未知时， 可以使用责任链模式。</li>
<li>当必须按顺序执行多个处理者时， 可以使用该模式。</li>
<li>如果所需处理者及其顺序必须在运行时进行改变， 可以使用责任链模式。</li>
</ul>
<h2 id="观察者模式"><a href="#观察者模式" class="headerlink" title="观察者模式"></a>观察者模式</h2><p>观察者模式定义了一种一对多的依赖关系，让多个观察者对象同时监听某一个主题对象，这个主题对象在状态发生变化时，会通知所有观察者对象，使它们能够自动更新自己的行为。</p>
<p>在现实生活中，处处可见观察者模式，例如，微信中的订阅号，订阅博客和QQ微博中关注好友，这些都属于观察者模式的应用。</p>
<p><img src="https://gitee.com/vickchen/blogImgs/raw/master/img/%E8%A7%82%E5%AF%9F%E8%80%85.png" alt></p>
<h3 id="实现方法-3"><a href="#实现方法-3" class="headerlink" title="实现方法"></a>实现方法</h3><ol>
<li><p>仔细检查你的业务逻辑， 试着将其拆分为两个部分： 独立于其他代码的核心功能将作为发布者； 其他代码则将转化为一组订阅类。</p>
</li>
<li><p>声明订阅者接口。 该接口至少应声明一个 <code>update</code>方法。</p>
</li>
<li><p>声明发布者接口并定义一些接口来在列表中添加和删除订阅对象。 记住发布者必须仅通过订阅者接口与它们进行交互。</p>
</li>
<li><p>确定存放实际订阅列表的位置并实现订阅方法。 通常所有类型的发布者代码看上去都一样， 因此将列表放置在直接扩展自发布者接口的抽象类中是显而易见的。 具体发布者会扩展该类从而继承所有的订阅行为。</p>
<p>但是， 如果你需要在现有的类层次结构中应用该模式， 则可以考虑使用组合的方式： 将订阅逻辑放入一个独立的对象， 然后让所有实际订阅者使用该对象。</p>
</li>
<li><p>创建具体发布者类。 每次发布者发生了重要事件时都必须通知所有的订阅者。</p>
</li>
<li><p>在具体订阅者类中实现通知更新的方法。 绝大部分订阅者需要一些与事件相关的上下文数据。 这些数据可作为通知方法的参数来传递。</p>
<p>但还有另一种选择。 订阅者接收到通知后直接从通知中获取所有数据。 在这种情况下， 发布者必须通过更新方法将自身传递出去。 另一种不太灵活的方式是通过构造函数将发布者与订阅者永久性地连接起来。</p>
</li>
<li><p>客户端必须生成所需的全部订阅者， 并在相应的发布者处完成注册工作。</p>
</li>
</ol>
<h3 id="适用场景-3"><a href="#适用场景-3" class="headerlink" title="适用场景"></a>适用场景</h3><ul>
<li>当一个对象状态的改变需要改变其他对象， 或实际对象是事先未知的或动态变化的时， 可使用观察者模式。</li>
<li>当应用中的一些对象必须观察其他对象时， 可使用该模式。 但仅能在有限时间内或特定情况下使用。</li>
</ul>
<h2 id="模板方法模式"><a href="#模板方法模式" class="headerlink" title="模板方法模式"></a>模板方法模式</h2><p>模板方法模式是在一个抽象类中定义一个操作中的算法骨架，而将一些具体步骤实现延迟到子类中去实现。模板方法使得子类可以不改变算法结构的前提下，重新定义算法的特定步骤，从而达到复用代码的效果。</p>
<p>在现实生活中，有论文模板，简历模板等。在现实生活中，模板的概念是给定一定的格式，然后其他所有使用模板的人可以根据自己的需求去实现它。同样，模板方法也是这样的。</p>
<p><img src="https://gitee.com/vickchen/blogImgs/raw/master/img/%E6%A8%A1%E6%9D%BF%E6%96%B9%E6%B3%95.png" alt></p>
<h3 id="实现方法-4"><a href="#实现方法-4" class="headerlink" title="实现方法"></a>实现方法</h3><ol>
<li>分析目标算法， 确定能否将其分解为多个步骤。 从所有子类的角度出发， 考虑哪些步骤能够通用， 哪些步骤各不相同。</li>
<li>创建抽象基类并声明一个模板方法和代表算法步骤的一系列抽象方法。 在模板方法中根据算法结构依次调用相应步骤。 可用 <code>final</code>最终修饰模板方法以防止子类对其进行重写。</li>
<li>虽然可将所有步骤全都设为抽象类型， 但默认实现可能会给部分步骤带来好处， 因为子类无需实现那些方法。</li>
<li>可考虑在算法的关键步骤之间添加钩子。</li>
<li>为每个算法变体新建一个具体子类， 它<em>必须</em>实现所有的抽象步骤， 也<em>可以</em>重写部分可选步骤。</li>
</ol>
<h3 id="适用场景-4"><a href="#适用场景-4" class="headerlink" title="适用场景"></a>适用场景</h3><ul>
<li>当你只希望客户端扩展某个特定算法步骤， 而不是整个算法或其结构时， 可使用模板方法模式。</li>
<li>当多个类的算法除一些细微不同之外几乎完全一样时， 你可使用该模式。 但其后果就是， 只要算法发生变化， 你就可能需要修改所有的类。</li>
</ul>
<h2 id="迭代器模式"><a href="#迭代器模式" class="headerlink" title="迭代器模式"></a>迭代器模式</h2><p>迭代器模式提供了一种方法来顺序访问一个集合对象中各个元素，而又无需暴露该对象的内部表示，这样既可以做到不暴露集合的内部结构，又可以让外部代码透明地访问集合内部元素。</p>
<p>迭代器模式是针对集合对象而生的，对于集合对象而言，必然涉及到集合元素的添加删除操作，也肯定支持遍历集合元素的操作，此时如果把遍历操作也放在集合对象的话，集合对象就承担太多的责任了，此时可以进行责任分离，把集合的遍历放在另一个对象中，这个对象就是迭代器对象。</p>
<p><img src="https://gitee.com/vickchen/blogImgs/raw/master/img/%E8%BF%AD%E4%BB%A3%E5%99%A8.png" alt></p>
<h3 id="实现方法-5"><a href="#实现方法-5" class="headerlink" title="实现方法"></a>实现方法</h3><ol>
<li>声明迭代器接口。 该接口必须提供至少一个方法来获取集合中的下个元素。 但为了使用方便， 你还可以添加一些其他方法， 例如获取前一个元素、 记录当前位置和判断迭代是否已结束。</li>
<li>声明集合接口并描述一个获取迭代器的方法。 其返回值必须是迭代器接口。 如果你计划拥有多组不同的迭代器， 则可以声明多个类似的方法。</li>
<li>为希望使用迭代器进行遍历的集合实现具体迭代器类。 迭代器对象必须与单个集合实体链接。 链接关系通常通过迭代器的构造函数建立。</li>
<li>在你的集合类中实现集合接口。 其主要思想是针对特定集合为客户端代码提供创建迭代器的快捷方式。 集合对象必须将自身传递给迭代器的构造函数来创建两者之间的链接。</li>
<li>检查客户端代码， 使用迭代器替代所有集合遍历代码。 每当客户端需要遍历集合元素时都会获取一个新的迭代器。</li>
</ol>
<h3 id="适用场景-5"><a href="#适用场景-5" class="headerlink" title="适用场景"></a>适用场景</h3><ul>
<li>当集合背后为复杂的数据结构， 且你希望对客户端隐藏其复杂性时 （出于使用便利性或安全性的考虑）， 可以使用迭代器模式。</li>
<li>使用该模式可以减少程序中重复的遍历代码。</li>
<li>如果你希望代码能够遍历不同的甚至是无法预知的数据结构， 可以使用迭代器模式。</li>
</ul>
<h2 id="备忘录模式"><a href="#备忘录模式" class="headerlink" title="备忘录模式"></a>备忘录模式</h2><p>备忘录模式是在不破坏封装的前提下，捕获一个对象的内部状态，并在该对象之外保存这个状态，这样以后就可以把该对象恢复到原先的状态。</p>
<p>生活中的手机通讯录备忘录，操作系统备份点，数据库备份等都是备忘录模式的应用。</p>
<p><img src="https://gitee.com/vickchen/blogImgs/raw/master/img/%E5%A4%87%E5%BF%98%E5%BD%95.png" alt></p>
<h3 id="实现方法-6"><a href="#实现方法-6" class="headerlink" title="实现方法"></a>实现方法</h3><ol>
<li><p>确定担任原发器角色的类。 重要的是明确程序使用的一个原发器中心对象， 还是多个较小的对象。</p>
</li>
<li><p>创建备忘录类。 逐一声明对应每个原发器成员变量的备忘录成员变量。</p>
</li>
<li><p>将备忘录类设为不可变。 备忘录只能通过构造函数一次性接收数据。 该类中不能包含设置器。</p>
</li>
<li><p>如果你所使用的编程语言支持嵌套类， 则可将备忘录嵌套在原发器中； 如果不支持， 那么你可从备忘录类中抽取一个空接口， 然后让其他所有对象通过接口来引用备忘录。 你可在该接口中添加一些元数据操作， 但不能暴露原发器的状态。</p>
</li>
<li><p>在原发器中添加一个创建备忘录的方法。 原发器必须通过备忘录构造函数的一个或多个实际参数来将自身状态传递给备忘录。</p>
<p>该方法返回结果的类型必须是你在上一步中抽取的接口 （如果你已经抽取了）。 实际上， 创建备忘录的方法必须直接与备忘录类进行交互。</p>
</li>
<li><p>在原发器类中添加一个用于恢复自身状态的方法。 该方法接受备忘录对象作为参数。 如果你在之前的步骤中抽取了接口， 那么可将接口作为参数的类型。 在这种情况下， 你需要将输入对象强制转换为备忘录， 因为原发器需要拥有对该对象的完全访问权限。</p>
</li>
<li><p>无论负责人是命令对象、 历史记录或其他完全不同的东西， 它都必须要知道何时向原发器请求新的备忘录、 如何存储备忘录以及何时使用特定备忘录来对原发器进行恢复。</p>
</li>
<li><p>负责人与原发器之间的连接可以移动到备忘录类中。 在本例中， 每个备忘录都必须与创建自己的原发器相连接。 恢复方法也可以移动到备忘录类中， 但只有当备忘录类嵌套在原发器中， 或者原发器类提供了足够多的设置器并可对其状态进行重写时， 这种方式才能实现。</p>
</li>
</ol>
<h3 id="适用场景-6"><a href="#适用场景-6" class="headerlink" title="适用场景"></a>适用场景</h3><ul>
<li>当你需要创建对象状态快照来恢复其之前的状态时， 可以使用备忘录模式。</li>
<li>当直接访问对象的成员变量、 获取器或设置器将导致封装被突破时， 可以使用该模式。</li>
</ul>
<h2 id="访问者模式"><a href="#访问者模式" class="headerlink" title="访问者模式"></a>访问者模式</h2><p>访问者模式是封装一些施加于某种数据结构之上的操作。一旦这些操作需要修改的话，接受这个操作的数据结构则可以保存不变。访问者模式适用于数据结构相对稳定的系统， 它把数据结构和作用于数据结构之上的操作之间的耦合度降低，使得操作集合可以相对自由地改变。</p>
<p><img src="https://gitee.com/vickchen/blogImgs/raw/master/img/%E8%AE%BF%E9%97%AE%E8%80%85.png" alt></p>
<h3 id="实现方法-7"><a href="#实现方法-7" class="headerlink" title="实现方法"></a>实现方法</h3><ol>
<li><p>在访问者接口中声明一组 “访问” 方法， 分别对应程序中的每个具体元素类。</p>
</li>
<li><p>声明元素接口。 如果程序中已有元素类层次接口， 可在层次结构基类中添加抽象的 “接收” 方法。 该方法必须接受访问者对象作为参数。</p>
</li>
<li><p>在所有具体元素类中实现接收方法。 这些方法必须将调用重定向到当前元素对应的访问者对象中的访问者方法上。</p>
</li>
<li><p>元素类只能通过访问者接口与访问者进行交互。 不过访问者必须知晓所有的具体元素类， 因为这些类在访问者方法中都被作为参数类型引用。</p>
</li>
<li><p>为每个无法在元素层次结构中实现的行为创建一个具体访问者类并实现所有的访问者方法。</p>
<p>你可能会遇到访问者需要访问元素类的部分私有成员变量的情况。 在这种情况下， 你要么将这些变量或方法设为公有， 这将破坏元素的封装； 要么将访问者类嵌入到元素类中。 后一种方式只有在支持嵌套类的编程语言中才可能实现。</p>
</li>
<li><p>客户端必须创建访问者对象并通过 “接收” 方法将其传递给元素。</p>
</li>
</ol>
<h3 id="适用场景-7"><a href="#适用场景-7" class="headerlink" title="适用场景"></a>适用场景</h3><ul>
<li>如果你需要对一个复杂对象结构 （例如对象树） 中的所有元素执行某些操作， 可使用访问者模式。</li>
<li>可使用访问者模式来清理辅助行为的业务逻辑。</li>
<li>当某个行为仅在类层次结构中的一些类中有意义， 而在其他类中没有意义时， 可使用该模式。</li>
</ul>
<h2 id="中介者模式"><a href="#中介者模式" class="headerlink" title="中介者模式"></a>中介者模式</h2><p>中介者模式定义了一个中介对象来封装一系列对象之间的交互关系。中介者使各个对象之间不需要显式地相互引用，从而使耦合性降低，而且可以独立地改变它们之间的交互行为。</p>
<p>在现实生活中，有很多中介者模式的身影，例如QQ游戏平台，聊天室、QQ群和短信平台，这些都是中介者模式在现实生活中的应用。</p>
<p><img src="https://gitee.com/vickchen/blogImgs/raw/master/img/%E4%B8%AD%E4%BB%8B%E8%80%85.png" alt></p>
<h3 id="实现方法-8"><a href="#实现方法-8" class="headerlink" title="实现方法"></a>实现方法</h3><ol>
<li>找到一组当前紧密耦合， 且提供其独立性能带来更大好处的类 （例如更易于维护或更方便复用）。</li>
<li>声明中介者接口并描述中介者和各种组件之间所需的交流接口。 在绝大多数情况下， 一个接收组件通知的方法就足够了。 如果你希望在不同情景下复用组件类， 那么该接口将非常重要。 只要组件使用通用接口与其中介者合作， 你就能将该组件与不同实现中的中介者进行连接。</li>
<li>实现具体中介者类。 该类可从自行保存其下所有组件的引用中受益。</li>
<li>你可以更进一步， 让中介者负责组件对象的创建和销毁。 此后， 中介者可能会与<a href="https://refactoringguru.cn/design-patterns/abstract-factory" target="_blank" rel="noopener">工厂</a>或<a href="https://refactoringguru.cn/design-patterns/facade" target="_blank" rel="noopener">外观</a>类似。</li>
<li>组件必须保存对于中介者对象的引用。 该连接通常在组件的构造函数中建立， 该函数会将中介者对象作为参数传递。</li>
<li>修改组件代码， 使其可调用中介者的通知方法， 而非其他组件的方法。 然后将调用其他组件的代码抽取到中介者类中， 并在中介者接收到该组件通知时执行这些代码。</li>
</ol>
<h3 id="适用场景-8"><a href="#适用场景-8" class="headerlink" title="适用场景"></a>适用场景</h3><ul>
<li>当一些对象和其他对象紧密耦合以致难以对其进行修改时， 可使用中介者模式。</li>
<li>当组件因过于依赖其他组件而无法在不同应用中复用时， 可使用中介者模式。</li>
<li>如果为了能在不同情景下复用一些基本行为， 导致你需要被迫创建大量组件子类时， 可使用中介者模式。</li>
</ul>
<h2 id="解释器模式"><a href="#解释器模式" class="headerlink" title="解释器模式"></a>解释器模式</h2><p>解释器模式是给定一种语言，定义它文法的一种表示，并定义一种解释器，这个解释器使用该表示来解释器语言中的句子。</p>
<p>解释器模式是一个比较少用的模式，所以我自己也没有对该模式进行深入研究。在生活中，英汉词典的作用就是实现英文和中文互译，这就是解释器模式的应用。</p>
<h2 id="命令模式"><a href="#命令模式" class="headerlink" title="命令模式"></a>命令模式</h2><p>命令模式可将请求转换为一个包含与请求相关的所有信息的独立对象。 该转换让你能根据不同的请求将方法参数化、 延迟请求执行或将其放入队列中， 且能实现可撤销操作。</p>
<p><img src="https://gitee.com/vickchen/blogImgs/raw/master/img/%E5%91%BD%E4%BB%A4.png" alt></p>
<h3 id="实现方法-9"><a href="#实现方法-9" class="headerlink" title="实现方法"></a>实现方法</h3><ol>
<li>声明仅有一个执行方法的命令接口。</li>
<li>抽取请求并使之成为实现命令接口的具体命令类。 每个类都必须有一组成员变量来保存请求参数和对于实际接收者对象的引用。 所有这些变量的数值都必须通过命令构造函数进行初始化。</li>
<li>找到担任<em>发送者</em>职责的类。 在这些类中添加保存命令的成员变量。 发送者只能通过命令接口与其命令进行交互。 发送者自身通常并不创建命令对象， 而是通过客户端代码获取。</li>
<li>修改发送者使其执行命令， 而非直接将请求发送给接收者。</li>
<li>客户端必须按照以下顺序来初始化对象：<ul>
<li>创建接收者。</li>
<li>创建命令， 如有需要可将其关联至接收者。</li>
<li>创建发送者并将其与特定命令关联。</li>
</ul>
</li>
</ol>
<h3 id="适用场景-9"><a href="#适用场景-9" class="headerlink" title="适用场景"></a>适用场景</h3><ul>
<li>如果你需要通过操作来参数化对象， 可使用命令模式。</li>
<li>如果你想要将操作放入队列中、 操作的执行或者远程执行操作， 可使用命令模式。</li>
<li>如果你想要实现操作回滚功能， 可使用命令模式。</li>
</ul>
<p>设计模式系列：</p>
<ol>
<li><a href="http://vickchen.win/2017/201710220019/" target="_blank" rel="noopener">设计模式之设计原则</a></li>
<li><a href="http://vickchen.win/2017/201711300108/" target="_blank" rel="noopener">设计模式之创建型模式</a></li>
<li><a href="http://vickchen.win/2020/202004112301/" target="_blank" rel="noopener">设计模式之结构型模式</a></li>
<li><a href="http://vickchen.win/2020/202005192357/" target="_blank" rel="noopener">设计模式之行为模式</a></li>
</ol>
<p>参考 - <a href="https://refactoring.guru/" target="_blank" rel="noopener">深入设计模式</a></p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;行为型模式共有十一种：策略模式、模板方法模式、观察者模式、迭代器模式、责任链模式、命令模式、备忘录模式、状态模式、访问者模式、中介者模式、解释器模式。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;策略模式 ：封装不同的算法，算法之间能互相替换&lt;/li&gt;
&lt;li&gt;状态模式 ：根据不同的状态做出不同的行为&lt;/li&gt;
&lt;li&gt;责任链模式 ：将事件沿着链去处理&lt;/li&gt;
&lt;li&gt;观察者模式 ：状态发生改变时通知观察者，一对多的关系&lt;/li&gt;
&lt;li&gt;模板方法模式 ：定义一套流程模板，根据需要实现模板中的操作&lt;/li&gt;
&lt;li&gt;迭代器模式 ：提供一种方法顺序访问一个聚合对象中的各个元素&lt;/li&gt;
&lt;li&gt;备忘录模式 ：保存对象的状态，在需要时进行恢复&lt;/li&gt;
&lt;li&gt;访问者模式 ：稳定数据结构中，定义新的操作行为&lt;/li&gt;
&lt;li&gt;中介者模式 ：将网状结构转变为星型结构，所有行为都通过中介&lt;/li&gt;
&lt;li&gt;解释器模式 ：定义语法，并对其进行解释&lt;/li&gt;
&lt;li&gt;命令模式 ：将请求封装成命令，并记录下来，能够撤销与重做&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
      <category term="技术" scheme="VickChen.win/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="设计模式" scheme="VickChen.win/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>设计模式之结构型模式</title>
    <link href="VickChen.win/2020/202004112301/"/>
    <id>VickChen.win/2020/202004112301/</id>
    <published>2020-04-11T15:01:22.000Z</published>
    <updated>2020-07-23T11:48:37.126Z</updated>
    
    <content type="html"><![CDATA[<p>结构型模式包括适配器模式、桥接模式、装饰者模式、组合模式、外观模式、享元模式和代理模式。</p>
<ul>
<li>适配器模式注重转换接口，将不吻合的接口适配对接 </li>
<li>桥接模式注重分离接口与其实现，支持多维度变化 </li>
<li>组合模式注重统一接口，将“一对多”的关系转化为“一对一”的关系 </li>
<li>装饰者模式注重稳定接口，在此前提下为对象扩展功能 </li>
<li>外观模式注重简化接口，简化组件系统与外部客户程序的依赖关系 </li>
<li>享元模式注重保留接口，在内部使用共享技术优化对象存储 </li>
<li>代理模式注重假借接口，增加间接层来实现灵活控制</li>
</ul>
<a id="more"></a>
<p>结构型模式，顾名思义讨论的是类和对象的结构 ，主要用来将对象和类组装成较大的结构， 并同时保持结构的灵活和高效。它包括两种类型:</p>
<ul>
<li>类结构型模式：采用继承机制来组合接口或实现</li>
<li>对象结构型模式：通过组合对象的方式来实现新的功能</li>
</ul>
<h2 id="适配器模式"><a href="#适配器模式" class="headerlink" title="适配器模式"></a>适配器模式</h2><p>适配器模式意在转换接口，它能够使原本不能再一起工作的两个类一起工作，所以经常用来在类库的复用、代码迁移等方面。例如<code>DataAdapter</code>类就应用了适配器模式。</p>
<p>适配器不仅可以转换不同格式的数据， 其还有助于采用不同接口的对象之间的合作。 它的运作方式如下：</p>
<ol>
<li>适配器实现与其中一个现有对象兼容的接口。</li>
<li>现有对象可以使用该接口安全地调用适配器方法。</li>
<li>适配器方法被调用后将以另一个对象兼容的格式和顺序将请求传递给该对象。</li>
</ol>
<p><img src="https://gitee.com/vickchen/blogImgs/raw/master/img/%E9%80%82%E9%85%8D%E5%99%A8.png" alt></p>
<h3 id="实现方法"><a href="#实现方法" class="headerlink" title="实现方法"></a>实现方法</h3><ol>
<li>确保至少有两个类的接口不兼容：<ul>
<li>一个无法修改 （通常是第三方、 遗留系统或者存在众多已有依赖的类） 的功能性<em>服务</em>类。</li>
<li>一个或多个将受益于使用服务类的<em>客户端</em>类。</li>
</ul>
</li>
<li>声明客户端接口， 描述客户端如何与服务交互。</li>
<li>创建遵循客户端接口的适配器类。 所有方法暂时都为空。</li>
<li>在适配器类中添加一个成员变量用于保存对于服务对象的引用。 通常情况下会通过构造函数对该成员变量进行初始化， 但有时在调用其方法时将该变量传递给适配器会更方便。</li>
<li>依次实现适配器类客户端接口的所有方法。 适配器会将实际工作委派给服务对象， 自身只负责接口或数据格式的转换。</li>
<li>客户端必须通过客户端接口使用适配器。 这样一来， 你就可以在不影响客户端代码的情况下修改或扩展适配器。</li>
</ol>
<h3 id="适用场景"><a href="#适用场景" class="headerlink" title="适用场景"></a>适用场景</h3><ul>
<li>当你希望使用某个类， 但是其接口与其他代码不兼容时， 可以使用适配器类。</li>
<li>如果您需要复用这样一些类， 他们处于同一个继承体系， 并且他们又有了额外的一些共同的方法， 但是这些共同的方法不是所有在这一继承体系中的子类所具有的共性。</li>
</ul>
<h2 id="桥接模式"><a href="#桥接模式" class="headerlink" title="桥接模式"></a>桥接模式</h2><p>桥接模式旨在将抽象化与实现化解耦，使得两者可以独立地变化。意思就是说，桥接模式把原来基类的实现化细节再进一步进行抽象，构造到一个实现化的结构中，然后再把原来的基类改造成一个抽象化的等级结构，这样就可以实现系统在多个维度的独立变化。简单说就是可以将一个大类或一系列紧密相关的类拆分为抽象和实现两个独立的层次结构， 从而能在开发时分别使用。</p>
<p><img src="https://gitee.com/vickchen/blogImgs/raw/master/img/%E6%A1%A5%E6%8E%A5.png" alt></p>
<h3 id="实现方法-1"><a href="#实现方法-1" class="headerlink" title="实现方法"></a>实现方法</h3><ol>
<li>明确类中独立的维度。 独立的概念可能是： 抽象/平台， 域/基础设施， 前端/后端或接口/实现。</li>
<li>了解客户端的业务需求， 并在抽象基类中定义它们。</li>
<li>确定在所有平台上都可执行的业务。 并在通用实现接口中声明抽象部分所需的业务。</li>
<li>为你域内的所有平台创建实现类， 但需确保它们遵循实现部分的接口。</li>
<li>在抽象类中添加指向实现类型的引用成员变量。 抽象部分会将大部分工作委派给该成员变量所指向的实现对象。</li>
<li>如果你的高层逻辑有多个变体， 则可通过扩展抽象基类为每个变体创建一个精确抽象。</li>
<li>客户端代码必须将实现对象传递给抽象部分的构造函数才能使其能够相互关联。 此后， 客户端只需与抽象对象进行交互， 无需和实现对象打交道。</li>
</ol>
<h3 id="适用场景-1"><a href="#适用场景-1" class="headerlink" title="适用场景"></a>适用场景</h3><ul>
<li>如果你想要拆分或重组一个具有多重功能的庞杂类 （例如能与多个数据库服务器进行交互的类）， 可以使用桥接模式。</li>
<li>如果你希望在几个独立维度上扩展一个类， 可使用该模式。</li>
</ul>
<h2 id="组合模式"><a href="#组合模式" class="headerlink" title="组合模式"></a>组合模式</h2><p>组合模式（<strong>亦称：</strong> 对象树）将对象组合成树形结构，用来表示整体与部分的关系，并且能像使用独立对象一样使用它们，使得客户端将单个对象和组合对象同等对待。</p>
<p>如 .NET 中 <code>WinForm</code> 下<code>TextBox</code>、<code>Label</code>等简单控件继承自<code>Control</code>类，同时<code>GroupBox</code>这样的组合控件也是继承于<code>Control</code>类。</p>
<p><img src="https://gitee.com/vickchen/blogImgs/raw/master/img/%E7%BB%84%E5%90%88.png" alt></p>
<h3 id="实现方法-2"><a href="#实现方法-2" class="headerlink" title="实现方法"></a>实现方法</h3><ol>
<li><p>确保应用的核心模型能够以树状结构表示。 尝试将其分解为简单元素和容器。 记住， 容器必须能够同时包含简单元素和其他容器。</p>
</li>
<li><p>声明组件接口及其一系列方法， 这些方法对简单和复杂元素都有意义。</p>
</li>
<li><p>创建一个叶节点类表示简单元素。 程序中可以有多个不同的叶节点类。</p>
</li>
<li><p>创建一个容器类表示复杂元素。 在该类中， 创建一个数组成员变量来存储对于其子元素的引用。 该数组必须能够同时保存叶节点和容器， 因此请确保将其声明为组合接口类型。</p>
<p>实现组件接口方法时， 记住容器应该将大部分工作交给其子元素来完成。</p>
</li>
<li><p>最后， 在容器中定义添加和删除子元素的方法。</p>
<p>记住， 这些操作可在组件接口中声明。 这将会违反<em>接口隔离原则</em>， 因为叶节点类中的这些方法为空。 但是， 这可以让客户端无差别地访问所有元素， 即使是组成树状结构的元素。</p>
</li>
</ol>
<h3 id="适用场景-2"><a href="#适用场景-2" class="headerlink" title="适用场景"></a>适用场景</h3><ul>
<li>如果你需要实现树状对象结构， 可以使用组合模式。</li>
<li>如果你希望客户端代码以相同方式处理简单和复杂元素， 可以使用该模式。</li>
</ul>
<h2 id="装饰模式"><a href="#装饰模式" class="headerlink" title="装饰模式"></a>装饰模式</h2><p>装饰模式（<strong>亦称：</strong> 包装模式）可以动态地给一个对象添加一些额外的功能，装饰者模式较继承生成子类的方式更加灵活。虽然装饰者模式能够动态地将职责附加到对象上，但它也会造成产生一些细小的对象，增加了系统的复杂度。</p>
<p><img src="https://gitee.com/vickchen/blogImgs/raw/master/img/%E8%A3%85%E9%A5%B0.png" alt></p>
<h3 id="实现方法-3"><a href="#实现方法-3" class="headerlink" title="实现方法"></a>实现方法</h3><ol>
<li>确保业务逻辑可用一个基本组件及多个额外可选层次表示。</li>
<li>找出基本组件和可选层次的通用方法。 创建一个组件接口并在其中声明这些方法。</li>
<li>创建一个具体组件类， 并定义其基础行为。</li>
<li>创建装饰基类， 使用一个成员变量存储指向被封装对象的引用。 该成员变量必须被声明为组件接口类型， 从而能在运行时连接具体组件和装饰。 装饰基类必须将所有工作委派给被封装的对象。</li>
<li>确保所有类实现组件接口。</li>
<li>将装饰基类扩展为具体装饰。 具体装饰必须在调用父类方法 （总是委派给被封装对象） 之前或之后执行自身的行为。</li>
<li>客户端代码负责创建装饰并将其组合成客户端所需的形式。</li>
</ol>
<h3 id="适用场景-3"><a href="#适用场景-3" class="headerlink" title="适用场景"></a>适用场景</h3><ul>
<li>如果你希望在无需修改代码的情况下即可使用对象， 且希望在运行时为对象新增额外的行为， 可以使用装饰模式。</li>
<li>如果用继承来扩展对象行为的方案难以实现或者根本不可行， 你可以使用该模式。</li>
</ul>
<h2 id="外观模式"><a href="#外观模式" class="headerlink" title="外观模式"></a>外观模式</h2><p>外观模式可以为包含许多活动部件的复杂子系统提供一个简单的接口。 与直接调用子系统相比， 外观提供的功能可能比较有限， 但它却包含了客户端真正关心的功能。</p>
<p>如果你的程序需要与包含几十种功能的复杂库整合， 但只需使用其中非常少的功能， 那么使用外观模式会非常方便。</p>
<p><img src="https://gitee.com/vickchen/blogImgs/raw/master/img/%E5%A4%96%E8%A7%82.png" alt></p>
<h3 id="实现方法-4"><a href="#实现方法-4" class="headerlink" title="实现方法"></a>实现方法</h3><ol>
<li>考虑能否在现有子系统的基础上提供一个更简单的接口。 如果该接口能让客户端代码独立于众多子系统类， 那么你的方向就是正确的。</li>
<li>在一个新的外观类中声明并实现该接口。 外观应将客户端代码的调用重定向到子系统中的相应对象处。 如果客户端代码没有对子系统进行初始化， 也没有对其后续生命周期进行管理， 那么外观必须完成此类工作。</li>
<li>如果要充分发挥这一模式的优势， 你必须确保所有客户端代码仅通过外观来与子系统进行交互。 此后客户端代码将不会受到任何由子系统代码修改而造成的影响， 比如子系统升级后， 你只需修改外观中的代码即可。</li>
<li>如果外观变得过于臃肿， 你可以考虑将其部分行为抽取为一个新的专用外观类。</li>
</ol>
<h3 id="适用场景-4"><a href="#适用场景-4" class="headerlink" title="适用场景"></a>适用场景</h3><ul>
<li>如果你需要一个指向复杂子系统的直接接口， 且该接口的功能有限， 则可以使用外观模式。</li>
<li>如果需要将子系统组织为多层结构， 可以使用外观。</li>
</ul>
<h2 id="享元模式"><a href="#享元模式" class="headerlink" title="享元模式"></a>享元模式</h2><p>享元模式是一种结构型设计模式， 它摒弃了在每个对象中保存所有数据的方式， 通过共享多个对象所共有的相同状态， 让你能在有限的内存容量中载入更多对象。</p>
<p>在系统中，如何我们需要重复使用某个对象时，此时如果重复地使用new操作符来创建这个对象的话，这对系统资源是一个极大的浪费，既然每次使用的都是同一个对象，为什么不能对其共享呢？这也是享元模式出现的原因。</p>
<p>享元模式运用共享的技术有效地支持细粒度的对象，使其进行共享。在.NET类库中，<code>String</code>类的实现就使用了享元模式，String类采用字符串驻留池的来使字符串进行共享。</p>
<p><img src="https://gitee.com/vickchen/blogImgs/raw/master/img/%E4%BA%AB%E5%85%83.png" alt></p>
<h3 id="实现方法-5"><a href="#实现方法-5" class="headerlink" title="实现方法"></a>实现方法</h3><ol>
<li>将需要改写为享元的类成员变量拆分为两个部分：<ul>
<li>内在状态： 包含不变的、 可在许多对象中重复使用的数据的成员变量。</li>
<li>外在状态： 包含每个对象各自不同的情景数据的成员变量</li>
</ul>
</li>
<li>保留类中表示内在状态的成员变量， 并将其属性设置为不可修改。 这些变量仅可在构造函数中获得初始数值。</li>
<li>找到所有使用外在状态成员变量的方法， 为在方法中所用的每个成员变量新建一个参数， 并使用该参数代替成员变量。</li>
<li>你可以有选择地创建工厂类来管理享元缓存池， 它负责在新建享元时检查已有的享元。 如果选择使用工厂， 客户端就只能通过工厂来请求享元， 它们需要将享元的内在状态作为参数传递给工厂。</li>
<li>客户端必须存储和计算外在状态 （情景）的数值， 因为只有这样才能调用享元对象的方法。 为了使用方便， 外在状态和引用享元的成员变量可以移动到单独的情景类中。</li>
</ol>
<h3 id="适用场景-5"><a href="#适用场景-5" class="headerlink" title="适用场景"></a>适用场景</h3><ul>
<li>仅在程序必须支持大量对象且没有足够的内存容量时使用享元模式。</li>
</ul>
<h2 id="代理模式"><a href="#代理模式" class="headerlink" title="代理模式"></a>代理模式</h2><p>代理模式指的是你能够提供对象的替代品或其占位符。 代理控制着对于原对象的访问， 并允许在将请求提交给对象前后进行一些处理。</p>
<p>在系统开发中，有些对象由于网络或其他的障碍，以至于不能直接对其访问，此时可以通过一个代理对象来实现对目标对象的访问。如.NET中的调用Web服务等操作。</p>
<p><img src="https://gitee.com/vickchen/blogImgs/raw/master/img/代理.png" alt></p>
<h3 id="实现方法-6"><a href="#实现方法-6" class="headerlink" title="实现方法"></a>实现方法</h3><ol>
<li>如果没有现成的服务接口， 你就需要创建一个接口来实现代理和服务对象的可交换性。 从服务类中抽取接口并非总是可行的， 因为你需要对服务的所有客户端进行修改， 让它们使用接口。 备选计划是将代理作为服务类的子类， 这样代理就能继承服务的所有接口了。</li>
<li>创建代理类， 其中必须包含一个存储指向服务的引用的成员变量。 通常情况下， 代理负责创建服务并对其整个生命周期进行管理。 在一些特殊情况下， 客户端会通过构造函数将服务传递给代理。</li>
<li>根据需求实现代理方法。 在大部分情况下， 代理在完成一些任务后应将工作委派给服务对象。</li>
<li>可以考虑新建一个构建方法来判断客户端可获取的是代理还是实际服务。 你可以在代理类中创建一个简单的静态方法， 也可以创建一个完整的工厂方法。</li>
<li>可以考虑为服务对象实现延迟初始化。</li>
</ol>
<h3 id="适用场景-6"><a href="#适用场景-6" class="headerlink" title="适用场景"></a>适用场景</h3><ul>
<li>延迟初始化 （虚拟代理）。 如果你有一个偶尔使用的重量级服务对象， 一直保持该对象运行会消耗系统资源时， 可使用代理模式。</li>
<li>访问控制 （保护代理）。 如果你只希望特定客户端使用服务对象， 这里的对象可以是操作系统中非常重要的部分， 而客户端则是各种已启动的程序 （包括恶意程序）， 此时可使用代理模式。</li>
<li>本地执行远程服务 （远程代理）。 适用于服务对象位于远程服务器上的情形。</li>
<li>记录日志请求 （日志记录代理）。 适用于当你需要保存对于服务对象的请求历史记录时。 代理可以在向服务传递请求前进行记录。</li>
<li>智能引用。 可在没有客户端使用某个重量级对象时立即销毁该对象。</li>
</ul>
<p>设计模式系列：</p>
<ol>
<li><a href="http://vickchen.win/2017/201710220019/" target="_blank" rel="noopener">设计模式之设计原则</a></li>
<li><a href="http://vickchen.win/2017/201711300108/" target="_blank" rel="noopener">设计模式之创建型模式</a></li>
<li><a href="http://vickchen.win/2020/202004112301/" target="_blank" rel="noopener">设计模式之结构型模式</a></li>
<li><a href="http://vickchen.win/2020/202005192357/" target="_blank" rel="noopener">设计模式之行为模式</a></li>
</ol>
<p>参考 - <a href="https://refactoring.guru/" target="_blank" rel="noopener">深入设计模式</a></p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;结构型模式包括适配器模式、桥接模式、装饰者模式、组合模式、外观模式、享元模式和代理模式。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;适配器模式注重转换接口，将不吻合的接口适配对接 &lt;/li&gt;
&lt;li&gt;桥接模式注重分离接口与其实现，支持多维度变化 &lt;/li&gt;
&lt;li&gt;组合模式注重统一接口，将“一对多”的关系转化为“一对一”的关系 &lt;/li&gt;
&lt;li&gt;装饰者模式注重稳定接口，在此前提下为对象扩展功能 &lt;/li&gt;
&lt;li&gt;外观模式注重简化接口，简化组件系统与外部客户程序的依赖关系 &lt;/li&gt;
&lt;li&gt;享元模式注重保留接口，在内部使用共享技术优化对象存储 &lt;/li&gt;
&lt;li&gt;代理模式注重假借接口，增加间接层来实现灵活控制&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
      <category term="技术" scheme="VickChen.win/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="设计模式" scheme="VickChen.win/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>.Net Core 3.1 使用Autofac</title>
    <link href="VickChen.win/2020/202002182318/"/>
    <id>VickChen.win/2020/202002182318/</id>
    <published>2020-02-18T15:18:31.000Z</published>
    <updated>2020-07-18T08:48:38.951Z</updated>
    
    <content type="html"><![CDATA[<p>在ASP.NET Core中,自带的IOC容器相关的使用方式和注入类型的生命周期.</p>
<p>微软给自行注入的服务,提供了3种生命周期.</p>
<ul>
<li><p>Transient(瞬时的)</p>
<p> 每次请求时都会创建的瞬时生命周期服务。这个生命周期最适合轻量级，无状态的服务。</p>
</li>
<li><p>Scoped(作用域的)</p>
<p>在同作用域,服务每个请求只创建一次。</p>
</li>
<li><p>Singleton(唯一的)</p>
<p>全局只创建一次,第一次被请求的时候被创建,然后就一直使用这一个.</p>
</li>
</ul>
<p>自带的IOC 并不支持AOP（面向切面编程），所以我们最好还是使用Autofac.</p>
<a id="more"></a>
<ol>
<li><p>从nuget引用包</p>
<ul>
<li>Autofac</li>
<li>Autofac.Extensions.DependencyInjection </li>
</ul>
</li>
<li><p>在Program.cs 新增一行代码</p>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> IHostBuilder <span class="title">CreateHostBuilder</span>(<span class="params"><span class="keyword">string</span>[] args</span>)</span> =&gt;</span><br><span class="line">           Host.CreateDefaultBuilder(args)</span><br><span class="line">               .UseServiceProviderFactory(<span class="keyword">new</span> AutofacServiceProviderFactory())<span class="comment">//使用AutoFac做IOC和AOP</span></span><br><span class="line">   </span><br><span class="line">               .ConfigureWebHostDefaults(webBuilder =&gt;</span><br><span class="line">               &#123;</span><br><span class="line">                   webBuilder.UseStartup&lt;Startup&gt;();</span><br><span class="line">                   webBuilder.UseUrls(<span class="string">"http://*:8080"</span>);</span><br><span class="line">               &#125;);</span><br></pre></td></tr></table></figure>
</li>
<li><p>在Startup.cs 增加方法</p>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">ConfigureContainer</span>(<span class="params">ContainerBuilder containerBuilder</span>)</span></span><br><span class="line"><span class="function"></span>        &#123;</span><br><span class="line">            containerBuilder.RegisterModule&lt;ConfigureAutofac&gt;();</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure>
<p>ConfigureAutofac 是自己封装的一个类 继承了 Autofac.Module 也可以将以下代码直接写在这个方法里面:</p>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">ConfigureAutofac</span> : <span class="title">Module</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="function"><span class="keyword">protected</span> <span class="keyword">override</span> <span class="keyword">void</span> <span class="title">Load</span>(<span class="params">ContainerBuilder containerBuilder</span>)</span></span><br><span class="line"><span class="function"></span>        &#123;</span><br><span class="line">            <span class="comment">//程序集范围注入 名称注入</span></span><br><span class="line">            <span class="keyword">var</span> service = Assembly.Load(<span class="string">"Services"</span>);</span><br><span class="line">            <span class="keyword">var</span> iService = Assembly.Load(<span class="string">"IServices"</span>);</span><br><span class="line">            containerBuilder.RegisterAssemblyTypes(service, iService)</span><br><span class="line">                .Where(t =&gt; t.Name.EndsWith(<span class="string">"Service"</span>))</span><br><span class="line">                .AsImplementedInterfaces().PropertiesAutowired();</span><br><span class="line">            <span class="keyword">var</span> repository = Assembly.Load(<span class="string">"Repository"</span>);</span><br><span class="line">            <span class="keyword">var</span> iRepository = Assembly.Load(<span class="string">"IRepository"</span>);</span><br><span class="line">            containerBuilder.RegisterAssemblyTypes(repository, iRepository)</span><br><span class="line">                .Where(t =&gt; t.Name.EndsWith(<span class="string">"Repository"</span>))</span><br><span class="line">                .AsImplementedInterfaces().PropertiesAutowired();</span><br><span class="line"></span><br><span class="line">            <span class="comment">//注册当前程序集中以“Ser”结尾的类,暴漏类实现的所有接口，生命周期为PerLifetimeScope</span></span><br><span class="line">            <span class="comment">//containerBuilder.RegisterAssemblyTypes(System.Reflection.Assembly.GetExecutingAssembly()).Where(t =&gt; t.Name.EndsWith("Service")).AsImplementedInterfaces().InstancePerLifetimeScope();</span></span><br><span class="line">            <span class="comment">//containerBuilder.RegisterAssemblyTypes(System.Reflection.Assembly.GetExecutingAssembly()).Where(t =&gt; t.Name.EndsWith("Repository")).AsImplementedInterfaces().InstancePerLifetimeScope();</span></span><br><span class="line"></span><br><span class="line">            <span class="comment">//注册所有"Repository"程序集中的类</span></span><br><span class="line">            <span class="comment">//builder.RegisterAssemblyTypes(GetAssembly("Repository")).AsImplementedInterfaces();</span></span><br><span class="line"></span><br><span class="line">            <span class="comment">//单个注册</span></span><br><span class="line">            <span class="comment">//containerBuilder.RegisterType&lt;ExpertService&gt;().As&lt;IExpertService&gt;().PropertiesAutowired();</span></span><br><span class="line"></span><br><span class="line">            <span class="comment">//在控制器中使用属性依赖注入，其中注入属性必须标注为public</span></span><br><span class="line">            <span class="comment">//    var controllersTypesInAssembly = typeof(Startup).Assembly.GetExportedTypes()</span></span><br><span class="line">            <span class="comment">//    .Where(type =&gt; typeof(Microsoft.AspNetCore.Mvc.ControllerBase).IsAssignableFrom(type)).ToArray();</span></span><br><span class="line">            <span class="comment">//containerBuilder.RegisterTypes(controllersTypesInAssembly).PropertiesAutowired();</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>控制器通过构造函数注入，或者属性注入：</p>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">readonly</span> ITargetService _targetService;</span><br><span class="line">        <span class="keyword">private</span> IScopeService _scopeService &#123; <span class="keyword">get</span>; <span class="keyword">set</span>; &#125;<span class="comment">//属性注入</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">ExpertController</span>(<span class="params">ITargetService targetService</span>)</span></span><br><span class="line"><span class="function"></span>        &#123;</span><br><span class="line">            _targetService = targetService;</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure>
<p>其中属性注入需要在Startup.cs 的 ConfigureServices 方法下加入如下代码：</p>
<p><code>services.AddControllers().AddControllersAsServices();</code></p>
</li>
</ol>
<p><strong>注意： .Net Core 2.x和3.x 使用autofac注入方式不一样，此文仅适用于.Net Core 3.X</strong></p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;在ASP.NET Core中,自带的IOC容器相关的使用方式和注入类型的生命周期.&lt;/p&gt;
&lt;p&gt;微软给自行注入的服务,提供了3种生命周期.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;p&gt;Transient(瞬时的)&lt;/p&gt;
&lt;p&gt; 每次请求时都会创建的瞬时生命周期服务。这个生命周期最适合轻量级，无状态的服务。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;Scoped(作用域的)&lt;/p&gt;
&lt;p&gt;在同作用域,服务每个请求只创建一次。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;Singleton(唯一的)&lt;/p&gt;
&lt;p&gt;全局只创建一次,第一次被请求的时候被创建,然后就一直使用这一个.&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;自带的IOC 并不支持AOP（面向切面编程），所以我们最好还是使用Autofac.&lt;/p&gt;
    
    </summary>
    
      <category term="技术" scheme="VickChen.win/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="CSharp" scheme="VickChen.win/tags/CSharp/"/>
    
      <category term=".Net Core" scheme="VickChen.win/tags/Net-Core/"/>
    
      <category term="Autofac" scheme="VickChen.win/tags/Autofac/"/>
    
  </entry>
  
  <entry>
    <title>.NET开源分布式事务解决方案-CAP</title>
    <link href="VickChen.win/2019/201911272238/"/>
    <id>VickChen.win/2019/201911272238/</id>
    <published>2019-11-27T14:38:08.000Z</published>
    <updated>2020-07-23T12:00:06.699Z</updated>
    
    <content type="html"><![CDATA[<p>CAP 是一个在分布式系统中（SOA，MicroService）实现事件总线及最终一致性（分布式事务）的一个开源的 C# 库，她具有轻量级，高性能，易使用等特点。</p>
<p>你可以轻松的在基于 .NET Core 技术的分布式系统中引入CAP，包括但限于 ASP.NET Core 和 ASP.NET Core on .NET Framework。</p>
<ul>
<li>CAP 以 NuGet 包的形式提供，对项目无任何入侵，你仍然可以以你喜爱的方式来构建分布式系统。</li>
<li>CAP 具有 Event Bus 的所有功能，并且CAP提供了更加简化的方式来处理EventBus中的发布/订阅。</li>
<li>CAP 具有消息持久化的功能，也就是当你的服务进行重启或者宕机时，她可以保证消息的可靠性。</li>
<li>CAP 实现了分布式事务中的最终一致性，你不用再去处理这些琐碎的细节。</li>
<li>CAP 提供了基于 Microsoft DI 的 API 服务，她可以和你的 ASP.NET Core 系统进行无缝结合，并且能够和你的业务代码集成支持强一致性的事务处理。</li>
<li>CAP 是开源免费的。CAP基于MIT协议开源，你可以免费的在你的私人或者商业项目中使用，不会有人向你收取任何费用。</li>
</ul>
<p>Github：<a href="https://github.com/dotnetcore/CAP" target="_blank" rel="noopener">https://github.com/dotnetcore/CAP</a></p>
<a id="more"></a>
<p>目前， CAP 同时支持使用 <code>RabbitMQ</code>，<code>Kafka</code>，<code>Azure Service Bus</code> 等进行底层之间的消息发送，你不需要具备这些消息队列的使用经验，仍然可以轻松的集成到项目中。</p>
<p>CAP 目前支持使用 <code>Sql Server</code>，<code>MySql</code>，<code>PostgreSql</code>，<code>MongoDB</code> 数据库的项目。</p>
<p>CAP 同时支持使用 <code>EntityFrameworkCore</code> 和 <code>ADO.NET</code> 的项目，你可以根据需要选择不同的配置方式。</p>
<h2 id="Getting-Started"><a href="#Getting-Started" class="headerlink" title="Getting Started"></a>Getting Started</h2><h3 id="NuGet"><a href="#NuGet" class="headerlink" title="NuGet"></a>NuGet</h3><p>你可以运行以下下命令在你的项目中安装 CAP。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">PM&gt; Install-Package DotNetCore.CAP</span><br></pre></td></tr></table></figure>
<p>CAP 支持 Kafka、RabbitMQ、AzureServiceBus 等消息队列，你可以按需选择下面的包进行安装：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">PM&gt; Install-Package DotNetCore.CAP.Kafka</span><br><span class="line">PM&gt; Install-Package DotNetCore.CAP.RabbitMQ</span><br><span class="line">PM&gt; Install-Package DotNetCore.CAP.AzureServiceBus</span><br></pre></td></tr></table></figure>
<p>CAP 提供了 Sql Server, MySql, PostgreSQL，MongoDB 的扩展作为数据库存储：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">// 按需选择安装你正在使用的数据库</span><br><span class="line">PM&gt; Install-Package DotNetCore.CAP.SqlServer</span><br><span class="line">PM&gt; Install-Package DotNetCore.CAP.MySql</span><br><span class="line">PM&gt; Install-Package DotNetCore.CAP.PostgreSql</span><br><span class="line">PM&gt; Install-Package DotNetCore.CAP.MongoDB</span><br></pre></td></tr></table></figure>
<h3 id="Configuration"><a href="#Configuration" class="headerlink" title="Configuration"></a>Configuration</h3><p>首先配置CAP到 Startup.cs 文件中，如下：</p>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">ConfigureServices</span>(<span class="params">IServiceCollection services</span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ......</span><br><span class="line"></span><br><span class="line">    services.AddDbContext&lt;AppDbContext&gt;();</span><br><span class="line"></span><br><span class="line">    services.AddCap(x =&gt;</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//如果你使用的 EF 进行数据操作，你需要添加如下配置：</span></span><br><span class="line">        x.UseEntityFramework&lt;AppDbContext&gt;();  <span class="comment">//可选项，你不需要再次配置 x.UseSqlServer 了</span></span><br><span class="line">		</span><br><span class="line">        <span class="comment">//如果你使用的ADO.NET，根据数据库选择进行配置：</span></span><br><span class="line">        x.UseSqlServer(<span class="string">"数据库连接字符串"</span>);</span><br><span class="line">        x.UseMySql(<span class="string">"数据库连接字符串"</span>);</span><br><span class="line">        x.UsePostgreSql(<span class="string">"数据库连接字符串"</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//如果你使用的 MongoDB，你可以添加如下配置：</span></span><br><span class="line">        x.UseMongoDB(<span class="string">"ConnectionStrings"</span>);  <span class="comment">//注意，仅支持MongoDB 4.0+集群</span></span><br><span class="line">	</span><br><span class="line">        <span class="comment">//CAP支持 RabbitMQ、Kafka、AzureServiceBus 等作为MQ，根据使用选择配置：</span></span><br><span class="line">        x.UseRabbitMQ(<span class="string">"ConnectionStrings"</span>);</span><br><span class="line">        x.UseKafka(<span class="string">"ConnectionStrings"</span>);</span><br><span class="line">        x.UseAzureServiceBus(<span class="string">"ConnectionStrings"</span>);</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="发布"><a href="#发布" class="headerlink" title="发布"></a>发布</h3><p>在 Controller 中注入 <code>ICapPublisher</code> 然后使用 <code>ICapPublisher</code> 进行消息发送</p>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">PublishController</span> : <span class="title">Controller</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">readonly</span> ICapPublisher _capBus;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">PublishController</span>(<span class="params">ICapPublisher capPublisher</span>)</span></span><br><span class="line"><span class="function"></span>    &#123;</span><br><span class="line">        _capBus = capPublisher;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//不使用事务</span></span><br><span class="line">    [<span class="meta">Route(<span class="meta-string">"~/without/transaction"</span>)</span>]</span><br><span class="line">    <span class="function"><span class="keyword">public</span> IActionResult <span class="title">WithoutTransaction</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function"></span>    &#123;</span><br><span class="line">        _capBus.Publish(<span class="string">"xxx.services.show.time"</span>, DateTime.Now);</span><br><span class="line">	</span><br><span class="line">        <span class="keyword">return</span> Ok();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//Ado.Net 中使用事务，自动提交</span></span><br><span class="line">    [<span class="meta">Route(<span class="meta-string">"~/adonet/transaction"</span>)</span>]</span><br><span class="line">    <span class="function"><span class="keyword">public</span> IActionResult <span class="title">AdonetWithTransaction</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function"></span>    &#123;</span><br><span class="line">        <span class="keyword">using</span> (<span class="keyword">var</span> connection = <span class="keyword">new</span> MySqlConnection(ConnectionString))</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">using</span> (<span class="keyword">var</span> transaction = connection.BeginTransaction(_capBus, autoCommit: <span class="literal">true</span>))</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="comment">//业务代码</span></span><br><span class="line"></span><br><span class="line">                _capBus.Publish(<span class="string">"xxx.services.show.time"</span>, DateTime.Now);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> Ok();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//EntityFramework 中使用事务，自动提交</span></span><br><span class="line">    [<span class="meta">Route(<span class="meta-string">"~/ef/transaction"</span>)</span>]</span><br><span class="line">    <span class="function"><span class="keyword">public</span> IActionResult <span class="title">EntityFrameworkWithTransaction</span>(<span class="params">[FromServices]AppDbContext dbContext</span>)</span></span><br><span class="line"><span class="function"></span>    &#123;</span><br><span class="line">        <span class="keyword">using</span> (<span class="keyword">var</span> trans = dbContext.Database.BeginTransaction(_capBus, autoCommit: <span class="literal">true</span>))</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">//业务代码</span></span><br><span class="line"></span><br><span class="line">            _capBus.Publish(<span class="string">"xxx.services.show.time"</span>, DateTime.Now);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> Ok();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="订阅"><a href="#订阅" class="headerlink" title="订阅"></a>订阅</h3><p><strong>Action Method</strong></p>
<p>在 Action 上添加 <code>CapSubscribeAttribute</code> 来订阅相关消息。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">public class PublishController : Controller</span><br><span class="line">&#123;</span><br><span class="line">    [CapSubscribe(&quot;xxx.services.show.time&quot;)]</span><br><span class="line">    public void CheckReceivedMessage(DateTime datetime)</span><br><span class="line">    &#123;</span><br><span class="line">        Console.WriteLine(datetime);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>Service Method</strong></p>
<p>如果你的订阅方法没有位于 <code>Controller</code> 中，则你订阅的类需要继承 <code>ICapSubscribe</code>：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">namespace xxx.Service</span><br><span class="line">&#123;</span><br><span class="line">    public interface ISubscriberService</span><br><span class="line">    &#123;</span><br><span class="line">        public void CheckReceivedMessage(DateTime datetime);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public class SubscriberService: ISubscriberService, ICapSubscribe</span><br><span class="line">    &#123;</span><br><span class="line">        [CapSubscribe(&quot;xxx.services.show.time&quot;)]</span><br><span class="line">        public void CheckReceivedMessage(DateTime datetime)</span><br><span class="line">        &#123;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>然后在 Startup.cs 中的 <code>ConfigureServices()</code> 中注入你的 <code>ISubscriberService</code> 类</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">public void ConfigureServices(IServiceCollection services)</span><br><span class="line">&#123;</span><br><span class="line">    //注意: 注入的服务需要在 `services.AddCap()` 之前</span><br><span class="line">    services.AddTransient&lt;ISubscriberService,SubscriberService&gt;();</span><br><span class="line">	</span><br><span class="line">    services.AddCap(x=&gt;&#123;&#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="订阅者组"><a href="#订阅者组" class="headerlink" title="订阅者组"></a>订阅者组</h4><p>订阅者组的概念类似于 Kafka 中的消费者组，它和消息队列中的广播模式相同，用来处理不同微服务实例之间同时消费相同的消息。</p>
<p>当CAP启动的时候，她将创建一个默认的消费者组，如果多个相同消费者组的消费者消费同一个Topic消息的时候，只会有一个消费者被执行。 相反，如果消费者都位于不同的消费者组，则所有的消费者都会被执行。</p>
<p>相同的实例中，你可以通过下面的方式来指定他们位于不同的消费者组。</p>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">[<span class="meta">CapSubscribe(<span class="meta-string">"xxx.services.show.time"</span>, Group = <span class="meta-string">"group1"</span> )</span>]</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">ShowTime1</span>(<span class="params">DateTime datetime</span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">[<span class="meta">CapSubscribe(<span class="meta-string">"xxx.services.show.time"</span>, Group = <span class="meta-string">"group2"</span>)</span>]</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">ShowTime2</span>(<span class="params">DateTime datetime</span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>ShowTime1</code> 和 <code>ShowTime2</code> 处于不同的组，他们将会被同时调用。</p>
<p>PS，你可以通过下面的方式来指定默认的消费者组名称：</p>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">services.AddCap(x =&gt;</span><br><span class="line">&#123;</span><br><span class="line">    x.DefaultGroup = <span class="string">"default-group-name"</span>;  </span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<h3 id="Dashboard"><a href="#Dashboard" class="headerlink" title="Dashboard"></a>Dashboard</h3><p>CAP 2.1+ 以上版本中提供了仪表盘（Dashboard）功能，你可以很方便的查看发出和接收到的消息。除此之外，你还可以在仪表盘中实时查看发送或者接收到的消息。</p>
<p>使用一下命令安装 Dashboard：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">PM&gt; Install-Package DotNetCore.CAP.Dashboard</span><br></pre></td></tr></table></figure>
<p>在分布式环境中，仪表盘内置集成了 <a href="http://consul.io/" target="_blank" rel="noopener">Consul</a> 作为节点的注册发现，同时实现了网关代理功能，你同样可以方便的查看本节点或者其他节点的数据，它就像你访问本地资源一样。</p>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">services.AddCap(x =&gt;</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 注册 Dashboard</span></span><br><span class="line">    x.UseDashboard();</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 注册节点到 Consul</span></span><br><span class="line">    x.UseDiscovery(d =&gt;</span><br><span class="line">    &#123;</span><br><span class="line">        d.DiscoveryServerHostName = <span class="string">"localhost"</span>;</span><br><span class="line">        d.DiscoveryServerPort = <span class="number">8500</span>;</span><br><span class="line">        d.CurrentNodeHostName = <span class="string">"localhost"</span>;</span><br><span class="line">        d.CurrentNodePort = <span class="number">5800</span>;</span><br><span class="line">        d.NodeId = <span class="number">1</span>;</span><br><span class="line">        d.NodeName = <span class="string">"CAP No.1 Node"</span>;</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<p>仪表盘默认的访问地址是：<a href="http://localhost:xxx/cap，你可以在`d.MatchPath`配置项中修改`cap`路径后缀为其他的名字。" target="_blank" rel="noopener">http://localhost:xxx/cap，你可以在`d.MatchPath`配置项中修改`cap`路径后缀为其他的名字。</a></p>
<p><em>本文转载自 -<a href="https://github.com/dotnetcore/CAP/blob/master/README.zh-cn" target="_blank" rel="noopener">README</a></em></p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;CAP 是一个在分布式系统中（SOA，MicroService）实现事件总线及最终一致性（分布式事务）的一个开源的 C# 库，她具有轻量级，高性能，易使用等特点。&lt;/p&gt;
&lt;p&gt;你可以轻松的在基于 .NET Core 技术的分布式系统中引入CAP，包括但限于 ASP.NET Core 和 ASP.NET Core on .NET Framework。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;CAP 以 NuGet 包的形式提供，对项目无任何入侵，你仍然可以以你喜爱的方式来构建分布式系统。&lt;/li&gt;
&lt;li&gt;CAP 具有 Event Bus 的所有功能，并且CAP提供了更加简化的方式来处理EventBus中的发布/订阅。&lt;/li&gt;
&lt;li&gt;CAP 具有消息持久化的功能，也就是当你的服务进行重启或者宕机时，她可以保证消息的可靠性。&lt;/li&gt;
&lt;li&gt;CAP 实现了分布式事务中的最终一致性，你不用再去处理这些琐碎的细节。&lt;/li&gt;
&lt;li&gt;CAP 提供了基于 Microsoft DI 的 API 服务，她可以和你的 ASP.NET Core 系统进行无缝结合，并且能够和你的业务代码集成支持强一致性的事务处理。&lt;/li&gt;
&lt;li&gt;CAP 是开源免费的。CAP基于MIT协议开源，你可以免费的在你的私人或者商业项目中使用，不会有人向你收取任何费用。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Github：&lt;a href=&quot;https://github.com/dotnetcore/CAP&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://github.com/dotnetcore/CAP&lt;/a&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="技术" scheme="VickChen.win/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="CSharp" scheme="VickChen.win/tags/CSharp/"/>
    
      <category term=".Net Core" scheme="VickChen.win/tags/Net-Core/"/>
    
      <category term="分布式" scheme="VickChen.win/tags/%E5%88%86%E5%B8%83%E5%BC%8F/"/>
    
      <category term="CAP" scheme="VickChen.win/tags/CAP/"/>
    
  </entry>
  
  <entry>
    <title>分布式事务常用解决方案</title>
    <link href="VickChen.win/2019/201911030147/"/>
    <id>VickChen.win/2019/201911030147/</id>
    <published>2019-11-02T17:47:55.000Z</published>
    <updated>2020-07-15T05:02:11.714Z</updated>
    
    <content type="html"><![CDATA[<p>业界目前主流的分布式事务解决方案主要有：多阶段提交方案（2PC、3PC）、本地消息表、补偿事务（TCC）和消息事务（主要是RocketMQ）。这些方案的原理在此处不展开，目前网络中相应资料比较多，小结一下它们的特点</p>
<a id="more"></a>
<h2 id="多阶段提交方案"><a href="#多阶段提交方案" class="headerlink" title="多阶段提交方案"></a>多阶段提交方案</h2><p>常见的有二阶段（<strong>2PC</strong>）和三阶段（<strong>3PC</strong>）提交事务，需要额外的资源管理器来协调事务，数据一致性强，但是实现方案比较复杂，对性能的牺牲比较大（主要是需要对资源锁定，等待所有事务提交才能解锁），不适用于高并发的场景，目前比较知名的有阿里开源的<a href="https://github.com/alibaba/fescar" target="_blank" rel="noopener">fescar</a>。</p>
<h2 id="补偿事务（TCC）"><a href="#补偿事务（TCC）" class="headerlink" title="补偿事务（TCC）"></a>补偿事务（TCC）</h2><p>因为每个事务操作都需要提供三个操作尝试（<code>Try</code>）、确认（<code>Confirm</code>）和补偿/撤销（<code>Cancel</code>），数据一致性的强度比多阶段提交方案低，但是实现的复杂度会有所降低，比较明显的缺陷是每个业务事务需要实现三组操作，有可能出现过多的补偿方案的代码；另外有很多输完液场景TCC是不合适的。</p>
<h2 id="本地消息表"><a href="#本地消息表" class="headerlink" title="本地消息表"></a>本地消息表</h2><p>这种实现方式应该是业界使用最多的，其核心思想是将分布式事务拆分成本地事务进行处理，这种思路是来源于ebay。后来通过支付宝等公司的布道，在业内广泛使用。其设计思想是将远程分布式事务拆分成一系列的本地事务。如果不考虑性能及设计优雅，借助关系型数据库中的表即可实现。</p>
<p>基本思路就是：</p>
<p>消息生产方，需要额外建一个消息表，并记录消息发送状态。消息表和业务数据要在一个事务里提交，也就是说他们要在一个数据库里面。然后消息会经过MQ发送到消息的消费方。如果消息发送失败，会进行重试发送。</p>
<p>消息消费方，需要处理这个消息，并完成自己的业务逻辑。此时如果本地事务处理成功，表明已经处理成功了，如果处理失败，那么就会重试执行。如果是业务上面的失败，可以给生产方发送一个业务补偿消息，通知生产方进行回滚等操作。</p>
<p>生产方和消费方定时扫描本地消息表，把还没处理完成的消息或者失败的消息再发送一遍。如果有靠谱的自动对账补账逻辑，这种方案还是非常实用的。</p>
<p>这种方案遵循BASE理论，采用的是最终一致性，个人认为是这几种方案里面比较适合实际业务场景的，即不会出现像2PC那样复杂的实现(当调用链很长的时候，2PC的可用性是非常低的)，也不会像TCC那样可能出现确认或者回滚不了的情况。</p>
<h2 id="消息事务"><a href="#消息事务" class="headerlink" title="消息事务"></a>消息事务</h2><p>有一些第三方的MQ是支持事务消息的，比如RocketMQ，基本思想也是多阶段提交方案，并且基于中间提供件轮询和重试，其他消息队列中间件并没有实现分布式事务，比如 RabbitMQ 和 Kafka 都不支持。</p>
<p>以阿里的 RocketMQ 中间件为例，一个事务的执行流程包括：发送预消息、执行本地事务、确认消息发送成功。它的消息中间件存储了下游无法消费成功的消息，并且不断重试推送下游消费消息，而生产者（上游）需要提供一个<code>check</code>接口，用于检查成功发送预消息但是未确认最终消息发送状态的事务的状态。</p>
<p><strong>优点：</strong> 实现了最终一致性，不需要依赖本地数据库事务。</p>
<p><strong>缺点：</strong> 实现难度大，主流MQ不支持，没有.NET客户端，RocketMQ事务消息部分代码也未开源。</p>
<h2 id="Saga模式"><a href="#Saga模式" class="headerlink" title="Saga模式"></a>Saga模式</h2><p>Saga 模式适用于业务流程长且需要保证事务<strong>最终一致性</strong>的业务系统，Saga 模式一阶段就会提交本地事务，无锁、长流程情况下可以保证性能。</p>
<p>事务参与者可能是其它公司的服务或者是遗留系统的服务，无法进行改造和提供 TCC 要求的接口，可以使用 Saga 模式。</p>
<p><strong>优点：</strong></p>
<ul>
<li>一阶段提交本地数据库事务，无锁，高性能；</li>
<li>参与者可以采用事务驱动异步执行，高吞吐；</li>
<li>补偿服务即正向服务的“反向”，易于理解，易于实现；</li>
</ul>
<p><strong>缺点：</strong>由于一阶段已经提交本地数据库事务，且没有进行“预留”动作，所以不能保证隔离性。</p>
<p><em>本文参考 -<a href="https://www.cnblogs.com/savorboard/p/distributed-system-transaction-consistency.html" target="_blank" rel="noopener">Savorboard</a></em></p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;业界目前主流的分布式事务解决方案主要有：多阶段提交方案（2PC、3PC）、本地消息表、补偿事务（TCC）和消息事务（主要是RocketMQ）。这些方案的原理在此处不展开，目前网络中相应资料比较多，小结一下它们的特点&lt;/p&gt;
    
    </summary>
    
      <category term="技术" scheme="VickChen.win/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="分布式" scheme="VickChen.win/tags/%E5%88%86%E5%B8%83%E5%BC%8F/"/>
    
      <category term="Saga" scheme="VickChen.win/tags/Saga/"/>
    
      <category term="TCC" scheme="VickChen.win/tags/TCC/"/>
    
      <category term="MQ" scheme="VickChen.win/tags/MQ/"/>
    
  </entry>
  
  <entry>
    <title>分布式事务理论</title>
    <link href="VickChen.win/2019/201910172341/"/>
    <id>VickChen.win/2019/201910172341/</id>
    <published>2019-10-17T15:41:06.000Z</published>
    <updated>2020-07-15T05:00:26.770Z</updated>
    
    <content type="html"><![CDATA[<p>说到事务，可能大家首先想到的就是数据库事务。对于数据库事务可能大家都很熟悉，在开发过程中也会经常使用到。众所周知，数据库能实现<strong>本地事务</strong>，但现在的系统常采用微服务、SOA等架构，因此就出现了跨多个数据库的事务需求，这种事务即为“分布式事务”。</p>
<p>分布式事务一直是企业集成中的一个技术难点，也是每一个分布式系统架构中都会涉及到的一个东西，特别是在微服务架构中，几乎可以说是无法避免，本文就分布式事务来简单聊一下。</p>
<a id="more"></a>
<h2 id="事务的具体定义"><a href="#事务的具体定义" class="headerlink" title="事务的具体定义"></a>事务的具体定义</h2><p>事务提供一种机制将一个活动涉及的所有操作纳入到一个不可分割的执行单元，组成事务的所有操作只有在所有操作均能正常执行的情况下方能提交，只要其中任一操作执行失败，都将导致整个事务的回滚。简单地说，事务提供一种“要么什么都不做，要么做全做（All or Nothing）”机制。</p>
<h2 id="数据库事务"><a href="#数据库事务" class="headerlink" title="数据库事务"></a>数据库事务</h2><p>数据库事务（简称：事务，Transaction）是指数据库执行过程中的一个逻辑单位，由一个有限的数据库操作序列构成。</p>
<p>说到数据库事务，就不得不提一下事务著名的四大特性。</p>
<ul>
<li><strong>A:原子性(Atomicity)</strong> 事务是一个不可分割的执行单元，事务中的所有操作要么全都执行，要么全都不执行。</li>
<li><strong>C:一致性(Consistency)</strong> 事务在开始前和结束后，数据库的完整性约束没有被破坏。</li>
<li><strong>I:隔离性(Isolation)</strong> 事务的执行是相互独立的，它们不会相互干扰，一个事务不会看到另一个正在运行过程中的事务的数据。</li>
<li><strong>D:持久性(Durability)</strong> 一个事务完成之后，事务的执行结果必须是持久化保存的。即使数据库发生崩溃，在数据库恢复后事务提交的结果仍然不会丢失。</li>
</ul>
<blockquote>
<p>注意：事务只能保证数据库的<strong>高可靠性</strong>，即数据库本身发生问题后，事务提交后的数据仍然能恢复；而如果不是数据库本身的故障，如硬盘损坏了，那么事务提交的数据可能就丢失了。这属于『<strong>高可用性</strong>』的范畴。因此，事务只能保证数据库的『高可靠性』，而『高可用性』需要整个系统共同配合实现。</p>
</blockquote>
<p>具体关于事务的四种隔离级别之类的这里不再展开，有兴趣可以搜索一下相关资料。不过有一个知识点我们需要了解，就是假如数据库在提交事务的时候突然断电，那么它是怎么样恢复的呢？ 为什么要提到这个知识点呢？ 因为分布式系统的核心就是处理各种异常情况，这也是分布式系统复杂的地方，因为分布式的网络环境很复杂，这种“断电”故障要比单机多很多，所以我们在做分布式系统的时候，最先考虑的就是这种情况。</p>
<h2 id="分布式理论"><a href="#分布式理论" class="headerlink" title="分布式理论"></a>分布式理论</h2><p>本地事务主要限制在单个会话内，不涉及多个数据库资源。但是在基于微服务、 SOA（Service-Oriented Architecture，面向服务架构）的分布式应用环境下，越来越多的应用要求对多个数据库资源，多个服务的访问都能纳入到同一个事务当中，再想保证集群的ACID几乎是很难达到，或者即使能达到那么效率和性能会大幅下降，最为关键的是再很难扩展新的分区了，这时我们就需要引入一个新的理论原则来适应这种集群的情况，就是 CAP 原则，那么CAP原则指的是什么呢？</p>
<h3 id="CAP原则"><a href="#CAP原则" class="headerlink" title="CAP原则"></a>CAP原则</h3><p>又称CAP定理，是由加州大学伯克利分校Eric Brewer教授提出来的，他指出WEB服务无法同时满足以下3个属性：</p>
<ul>
<li>一致性(Consistency) ： 在分布式系统中的所有数据备份，在同一时刻是否同样的值。（等同于所有节点访问同一份最新的数据副本）</li>
<li>可用性(Availability) ： 在集群中一部分节点故障后，集群整体是否还能响应客户端的读写请求。（对数据更新具备高可用性）</li>
<li>分区容错性(Partition tolerance) ： 以实际效果而言，分区相当于对通信的时限要求。系统如果不能在时限内达成数据一致性，就意味着发生了分区的情况，必须就当前操作在C和A之间做出选择。</li>
</ul>
<p>CAP理论中说三者不可兼得，但实际情况是，<strong>在分布式场景中分区一定存在，也就必须要有分区容忍性对应的策略，之后才能在一致性和可用性间二者之间选择。所以对主流架构来说不是三选二，而是二选一。</strong></p>
<h3 id="BASE理论"><a href="#BASE理论" class="headerlink" title="BASE理论"></a>BASE理论</h3><p>在分布式系统中，我们往往追求的是可用性，它的重要程序比一致性要高，那么如何实现高可用性呢？ 前人已经给我们提出来了另外一个理论，就是BASE理论，它是用来对CAP定理进行进一步扩充的。BASE理论指的是：</p>
<ul>
<li>Basically Available（基本可用）</li>
<li>Soft state（软状态）</li>
<li>Eventually consistent（最终一致性）</li>
</ul>
<p>BASE理论是对CAP中的一致性和可用性进行一个权衡的结果，理论的核心思想就是：<strong>我们无法做到强一致，但每个应用都可以根据自身的业务特点，采用适当的方式来使系统达到最终一致性</strong>（Eventual consistency）。</p>
<p><em>本文参考 -<a href="https://www.cnblogs.com/savorboard/p/distributed-system-transaction-consistency.html" target="_blank" rel="noopener">Savorboard</a></em></p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;说到事务，可能大家首先想到的就是数据库事务。对于数据库事务可能大家都很熟悉，在开发过程中也会经常使用到。众所周知，数据库能实现&lt;strong&gt;本地事务&lt;/strong&gt;，但现在的系统常采用微服务、SOA等架构，因此就出现了跨多个数据库的事务需求，这种事务即为“分布式事务”。&lt;/p&gt;
&lt;p&gt;分布式事务一直是企业集成中的一个技术难点，也是每一个分布式系统架构中都会涉及到的一个东西，特别是在微服务架构中，几乎可以说是无法避免，本文就分布式事务来简单聊一下。&lt;/p&gt;
    
    </summary>
    
      <category term="技术" scheme="VickChen.win/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="分布式" scheme="VickChen.win/tags/%E5%88%86%E5%B8%83%E5%BC%8F/"/>
    
      <category term="CAP" scheme="VickChen.win/tags/CAP/"/>
    
      <category term="Transaction" scheme="VickChen.win/tags/Transaction/"/>
    
  </entry>
  
  <entry>
    <title>C# 8中的范围类型(Range Type)</title>
    <link href="VickChen.win/2019/201908122354/"/>
    <id>VickChen.win/2019/201908122354/</id>
    <published>2019-08-12T15:54:27.000Z</published>
    <updated>2020-07-12T13:21:14.114Z</updated>
    
    <content type="html"><![CDATA[<p>C# 8.0中加入了一个新的范围类型(Range Type)。</p>
<p>这里我们首先展示一些代码，并一步一步为代码添加一些不同的东西, 为大家展示一下范围类型的功能和用法。</p>
<a id="more"></a>
<p>我们最原始的代码如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">Copystatic void Main(string[] args)</span><br><span class="line">&#123;</span><br><span class="line">    var myArray = new string[] </span><br><span class="line">    &#123;</span><br><span class="line">        &quot;Item1&quot;,</span><br><span class="line">        &quot;Item2&quot;,</span><br><span class="line">        &quot;Item3&quot;,</span><br><span class="line">        &quot;Item4&quot;, </span><br><span class="line">        &quot;Item5&quot;</span><br><span class="line">    &#125;; </span><br><span class="line">    for(int i=1; i &lt;= 3; i++)</span><br><span class="line">        Console.WriteLine(myArray[i]);</span><br><span class="line">    Console.ReadLine();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里我们显示的定义了我们查询数组的索引1-3, 并输出他们的值。毫无疑问，当我们运行程序之后，代码结果如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">CopyItem2</span><br><span class="line">Item3</span><br><span class="line">Item4</span><br></pre></td></tr></table></figure>
<p>但是，假设我们不想使用for循环，而是想要使用这个名为“range”的新特性， 我们可以将代码重写为：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">Copystatic void Main(string[] args)</span><br><span class="line">&#123;</span><br><span class="line">    var myArray = new string[]</span><br><span class="line">    &#123;</span><br><span class="line">        &quot;Item1&quot;,</span><br><span class="line">        &quot;Item2&quot;,</span><br><span class="line">        &quot;Item3&quot;,</span><br><span class="line">        &quot;Item4&quot;,</span><br><span class="line">        &quot;Item5&quot;</span><br><span class="line">    &#125;; </span><br><span class="line">    foreach (var item in myArray[1..3])</span><br><span class="line">        Console.WriteLine(item);</span><br><span class="line">    Console.ReadLine();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>现在我们来运行程序。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">CopyItem2</span><br><span class="line">Item3</span><br></pre></td></tr></table></figure>
<p>结果比我们预想的少了一个。这是我们使用范围类型遇到的第一个问题。</p>
<blockquote>
<p><strong>范围的起始索引是包含的，范围的结束索引是排除的</strong></p>
</blockquote>
<p>如果我们修改一下我们的代码：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">Copystatic void Main(string[] args)</span><br><span class="line">&#123;</span><br><span class="line">    var myArray = new string[]</span><br><span class="line">    &#123;</span><br><span class="line">        &quot;Item1&quot;,</span><br><span class="line">        &quot;Item2&quot;,</span><br><span class="line">        &quot;Item3&quot;,</span><br><span class="line">        &quot;Item4&quot;,</span><br><span class="line">        &quot;Item5&quot;</span><br><span class="line">    &#125;; </span><br><span class="line">    foreach (var item in myArray[1..4])</span><br><span class="line">        Console.WriteLine(item);</span><br><span class="line">    Console.ReadLine();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>我们就会获得预想的结果。</p>
<h2 id="范围缩写"><a href="#范围缩写" class="headerlink" title="范围缩写"></a>范围缩写</h2><p>使用范围来定义起始和结束索引非常的好用。但是如何表示从一个索引开始直到数组的最后一个对象呢？</p>
<h3 id="从一个索引开始到数组的最后一个对象"><a href="#从一个索引开始到数组的最后一个对象" class="headerlink" title="从一个索引开始到数组的最后一个对象"></a>从一个索引开始到数组的最后一个对象</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">Copystatic void Main(string[] args)</span><br><span class="line">&#123;</span><br><span class="line">    var myArray = new string[]</span><br><span class="line">    &#123;</span><br><span class="line">        &quot;Item1&quot;,</span><br><span class="line">        &quot;Item2&quot;,</span><br><span class="line">        &quot;Item3&quot;,</span><br><span class="line">        &quot;Item4&quot;,</span><br><span class="line">        &quot;Item5&quot;</span><br><span class="line">    &#125;; </span><br><span class="line">    foreach (var item in myArray[1..])</span><br><span class="line">        Console.WriteLine(item);</span><br><span class="line">    Console.ReadLine();</span><br><span class="line"> </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>输出结果：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">CopyItem2</span><br><span class="line">Item3</span><br><span class="line">Item4</span><br><span class="line">Item5</span><br></pre></td></tr></table></figure>
<h3 id="从数组的第一个对象到指定索引"><a href="#从数组的第一个对象到指定索引" class="headerlink" title="从数组的第一个对象到指定索引"></a>从数组的第一个对象到指定索引</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Copyforeach (var item in myArray[..3])</span><br><span class="line">&#123;</span><br><span class="line">    Console.WriteLine(item);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>输出结果：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">CopyItem1</span><br><span class="line">Item2</span><br><span class="line">Item3</span><br></pre></td></tr></table></figure>
<h3 id="整个数组"><a href="#整个数组" class="headerlink" title="整个数组"></a>整个数组</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Copyforeach (var item in myArray[..])</span><br><span class="line">&#123;</span><br><span class="line">   Console.WriteLine(item);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>输出结果：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">CopyItem1</span><br><span class="line">Item2</span><br><span class="line">Item3</span><br><span class="line">Item4</span><br><span class="line">Item5</span><br></pre></td></tr></table></figure>
<h3 id="从数组的某个索引开始一直到距数组尾部某个索引"><a href="#从数组的某个索引开始一直到距数组尾部某个索引" class="headerlink" title="从数组的某个索引开始一直到距数组尾部某个索引"></a>从数组的某个索引开始一直到距数组尾部某个索引</h3><p>C# 8.0提供了<code>&lt;/code&gt;操作符，&lt;code&gt;</code>操作符表示从数组末尾计算索引。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Copyforeach (var item in myArray[1..^1])</span><br><span class="line">&#123;</span><br><span class="line">    Console.WriteLine(item);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>输出结果：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">CopyItem2</span><br><span class="line">Item3</span><br><span class="line">Item4</span><br></pre></td></tr></table></figure>
<h2 id="范围类型"><a href="#范围类型" class="headerlink" title="范围类型"></a>范围类型</h2><p>当我们编写<code>1..4</code>的时候，看起来就好像我们在使用新的语法，实际上这只是个语法糖，实际上它初始化一个<code>Range</code>类对象，就好像我们可以使用<code>{“1”, “2”, “3”}</code>就可以创建一个数组一样。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">Copystatic void Main(string[] args)</span><br><span class="line">&#123;</span><br><span class="line">    var myArray = new string[]</span><br><span class="line">    &#123;</span><br><span class="line">        &quot;Item1&quot;,</span><br><span class="line">        &quot;Item2&quot;,</span><br><span class="line">        &quot;Item3&quot;,</span><br><span class="line">        &quot;Item4&quot;,</span><br><span class="line">        &quot;Item5&quot;</span><br><span class="line">    &#125;; </span><br><span class="line">    Range range = 1..4; </span><br><span class="line">    foreach (var item in myArray[range])</span><br><span class="line">        Console.WriteLine(item);</span><br><span class="line">    Console.ReadLine();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="替代Substring方法"><a href="#替代Substring方法" class="headerlink" title="替代Substring方法"></a>替代Substring方法</h2><p>使用范围类型的另一个好处就是你可以使用它替换<code>String.Substring</code>方法, 写起来更加简单。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">CopyConsole.WriteLine(&quot;123456789&quot;[1..4]);</span><br></pre></td></tr></table></figure>
<p><em>本文转载自 - <a href="https://www.cnblogs.com/lwqlun/p/10095821.html" target="_blank" rel="noopener"><a href="https://www.cnblogs.com/lwqlun/" target="_blank" rel="noopener">LamondLu的博客</a></a></em></p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;C# 8.0中加入了一个新的范围类型(Range Type)。&lt;/p&gt;
&lt;p&gt;这里我们首先展示一些代码，并一步一步为代码添加一些不同的东西, 为大家展示一下范围类型的功能和用法。&lt;/p&gt;
    
    </summary>
    
      <category term="技术" scheme="VickChen.win/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="CSharp" scheme="VickChen.win/tags/CSharp/"/>
    
  </entry>
  
  <entry>
    <title>三种MySql避免重复插入记录方法</title>
    <link href="VickChen.win/2019/201907192012/"/>
    <id>VickChen.win/2019/201907192012/</id>
    <published>2019-07-19T12:12:05.000Z</published>
    <updated>2020-07-12T12:38:53.279Z</updated>
    
    <content type="html"><![CDATA[<p>mysql在存在主键冲突或者唯一键冲突的情况下，根据插入策略不同，一般有以下三种避免方法:<br>1、insert ignore<br>2、replace into<br>3、insert on duplicate key update</p>
<p>注意，除非表有一个PRIMARY KEY或UNIQUE索引，否则，使用以上三个语句没有意义，与使用单纯的INSERT INTO相同。</p>
<a id="more"></a>
<h2 id="insert-ignore"><a href="#insert-ignore" class="headerlink" title="insert ignore"></a>insert ignore</h2><ul>
<li>insert ignore会忽略数据库中已经存在的数据(根据主键或者唯一索引判断)，如果数据库没有数据，就插入新的数据，如果有数据的话就跳过这条数据。</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">INSERT IGNORE INTO `table_name` (`email`, `phone`, `user_id`) </span><br><span class="line">VALUES (&apos;test9@163.com&apos;, &apos;99999&apos;, &apos;9999&apos;);</span><br></pre></td></tr></table></figure>
<p>这样当有重复记录就会忽略,执行后返回数字0</p>
<p>还有个应用就是复制表,避免重复记录：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">INSERT IGNORE INTO `table_1` (`name`) SELECT `name` FROM `table_2`;</span><br></pre></td></tr></table></figure>
<h2 id="replace-into"><a href="#replace-into" class="headerlink" title="replace into"></a>replace into</h2><ul>
<li>replace into 首先尝试插入数据到表中。 如果发现表中已经有此行数据(根据主键或者唯一索引判断)则先删除此行数据，然后插入新的数据，否则，直接插入新数据。</li>
<li>使用replace into，你必须具有delete和insert权限。</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">REPLACE INTO `table_name`(`col_name`, ...) VALUES (...);</span><br><span class="line">REPLACE INTO `table_name` (`col_name`, ...) SELECT ...;</span><br><span class="line">REPLACE INTO `table_name` SET `col_name`=&apos;value&apos;,...</span><br></pre></td></tr></table></figure>
<h2 id="insert-on-duplicate-key-update"><a href="#insert-on-duplicate-key-update" class="headerlink" title="insert on duplicate key update"></a>insert on duplicate key update</h2><ul>
<li><p>如果在insert into 语句末尾指定了on duplicate key update，并且插入行后会导致在一个UNIQUE索引或PRIMARY KEY中出现重复值，则在出现重复值的行执行UPDATE；如果不会导致重复的问题，则插入新行，跟普通的insert into一样。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">--如果列a被定义为UNIQUE，并且包含值1，则以下两个语句具有相同的效果</span><br><span class="line">INSERT INTO `table` (`a`, `b`, `c`) VALUES (1, 2, 3) </span><br><span class="line">ON DUPLICATE KEY UPDATE `c`=`c`+1; </span><br><span class="line"></span><br><span class="line">UPDATE `table` SET `c`=`c`+1 WHERE `a`=1;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<ul>
<li><p>使用insert into，你必须具有insert和update权限。</p>
</li>
<li><p>如果有新记录被插入，则受影响行的值显示1；如果原有的记录被更新，则受影响行的值显示2；如果记录被更新前后值是一样的，则受影响行数的值显示0。 </p>
</li>
<li><p>当您使用on duplicate key update时，insert delayed (延迟插入)选项被忽略。</p>
</li>
</ul>
<h2 id="结论"><a href="#结论" class="headerlink" title="结论"></a>结论</h2><ol>
<li><p>这三种方法都能避免主键或者唯一索引重复导致的插入失败问题。</p>
</li>
<li><p>insert ignore 能忽略重复数据，只插入不重复的数据。</p>
</li>
<li><p>replace into 和 insert … on duplicate key update 都是替换原有的重复数据。</p>
</li>
<li><p>replace into 是删除原有的行后，在插入新行，如有自增id，这个会造成自增id的改变；</p>
</li>
<li><p>insert … on duplicate key update在遇到重复行时，会直接更新原有的行，具体更新哪些字段怎么更新，取决于update后的语句。</p>
</li>
<li>特别说明：UNIQUE索引将会对null字段失效，也就是说(a字段上建立唯一索引)：<code>INSERT INTO</code>test<code>(</code>a<code>) VALUES (NULL);</code> 是可以重复插入的（联合唯一索引也一样）。</li>
</ol>
<p><em>本文部分出自 - <a href="https://www.jianshu.com/p/751299bd5669" target="_blank" rel="noopener">MySQL避免插入重复记录的方法</a></em></p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;mysql在存在主键冲突或者唯一键冲突的情况下，根据插入策略不同，一般有以下三种避免方法:&lt;br&gt;1、insert ignore&lt;br&gt;2、replace into&lt;br&gt;3、insert on duplicate key update&lt;/p&gt;
&lt;p&gt;注意，除非表有一个PRIMARY KEY或UNIQUE索引，否则，使用以上三个语句没有意义，与使用单纯的INSERT INTO相同。&lt;/p&gt;
    
    </summary>
    
      <category term="技术" scheme="VickChen.win/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="MySql" scheme="VickChen.win/tags/MySql/"/>
    
  </entry>
  
  <entry>
    <title>layui table 工具栏列隐藏状态本地永久化保存</title>
    <link href="VickChen.win/2019/201906012003/"/>
    <id>VickChen.win/2019/201906012003/</id>
    <published>2019-06-01T12:03:32.000Z</published>
    <updated>2020-07-10T12:32:25.898Z</updated>
    
    <content type="html"><![CDATA[<p>由于table列比较多，有时候用户不需要看那么多列，虽然layui提供了隐藏列的接口。但页面刷新后就会复原，这时候就可以将数据保存至localStorage中实现本地永久化保存</p>
<a id="more"></a>
<p>只需要改他的几行源码。然后在那个界面写上一句<code>var tableFlag = &quot;xxx&quot;;</code></p>
<p> table.js便会根据这个来区分是在操作哪个表的数据。</p>
<p><img src="https://gitee.com/vickchen/blogImgs/raw/master/img/1.png" alt><br><img src="https://gitee.com/vickchen/blogImgs/raw/master/img/2.png" alt><br><img src="https://gitee.com/vickchen/blogImgs/raw/master/img/3.png" alt></p>
<p><em>本文部分转载自 - <a href="https://fly.layui.com/jie/47318/" target="_blank" rel="noopener">Layui官方社区</a></em></p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;由于table列比较多，有时候用户不需要看那么多列，虽然layui提供了隐藏列的接口。但页面刷新后就会复原，这时候就可以将数据保存至localStorage中实现本地永久化保存&lt;/p&gt;
    
    </summary>
    
      <category term="技术" scheme="VickChen.win/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="JavaScript" scheme="VickChen.win/tags/JavaScript/"/>
    
      <category term="layui" scheme="VickChen.win/tags/layui/"/>
    
  </entry>
  
  <entry>
    <title>使用PicGo批量迁移图床</title>
    <link href="VickChen.win/2019/201905270004/"/>
    <id>VickChen.win/2019/201905270004/</id>
    <published>2019-05-26T16:04:32.000Z</published>
    <updated>2019-07-20T09:03:24.000Z</updated>
    
    <content type="html"><![CDATA[<p>上次折腾完之后，感觉还是不太踏实，毕竟新浪已经准备禁止图床了，索性抽点时间一步到位的换个图床。</p>
<a id="more"></a>
<p>和以前一样，挑选了一圈，也是很纠结，最终还是下定决心直接使用 GitHub 了，稳定又方便。其实就是新建一个仓库，专门用来存放图片，只不过需要考虑一下图片过多、图片过大会不会被 GitHub 限制。</p>
<p>去 GitHub 搜索帮助文档，<a href="https://help.github.com/en/articles/what-is-my-disk-quota" target="_blank" rel="noopener">帮助文档信息 </a>，可以得知仓库最大为 100GB，但是官方建议保持在 1GB 以下，单个文件低于 100MB，因此用来存放文件绰绰有余。另外需要注意，仓库文件超过 1GB 时会收到 GitHub 的提醒邮件，超过 75GB 时，每次在提交时都会收到警告。</p>
<p>既然有这种限制，最好还是把图片压缩一下，推荐使用图片压缩工具：<a href="https://github.com/meowtec/Imagine" target="_blank" rel="noopener">Imagine</a> ，这个工具可以实时看到压缩效果，而且压缩率还不错，能到 50%。但是，如果想要保持图片的色彩度、还原度，压缩效果肯定是不行的，甚至有时候压缩后的图片比压缩前的还大。</p>
<p>迁移图片本来是个很麻烦的事情，要把图片迁移、博客文章里面的链接替换掉，但是还好有现成的工具可以使用，在这里推荐：<a href="https://github.com/Molunerfinn/PicGo" target="_blank" rel="noopener">PicGo</a> ，这个工具本来不是做图片迁移的，仅仅是图片上传生成链接而已，但是有人开发了插件，专门用来迁移 markdown 文件里面的图片，会自动迁移图片并且更新 markdown 里面的图片链接。这个插件是：<a href="https://github.com/PicGo/picgo-plugin-pic-migrater" target="_blank" rel="noopener">picgo-plugin-pic-migrater</a> ，而且，还可以支持批量迁移，指定一个文件夹，直接迁移文件夹里面的所有 markdown 文件。</p>
<p>详细的迁移步骤就不再记录，几个重要的步骤：在 GitHub 建立仓库、安装并配置PicGo ，安装并配置picgo-plugin-pic-migrater插件、鼠标右键点击插件选择文件夹、搞定。操作前切记备份好自己的 markdown 文件，以免迁移出现问题导致文件丢失。</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;上次折腾完之后，感觉还是不太踏实，毕竟新浪已经准备禁止图床了，索性抽点时间一步到位的换个图床。&lt;/p&gt;
    
    </summary>
    
      <category term="工具" scheme="VickChen.win/categories/%E5%B7%A5%E5%85%B7/"/>
    
    
      <category term="GitHub" scheme="VickChen.win/tags/GitHub/"/>
    
      <category term="Hexo" scheme="VickChen.win/tags/Hexo/"/>
    
      <category term="PicGo" scheme="VickChen.win/tags/PicGo/"/>
    
  </entry>
  
  <entry>
    <title>解决微博图床防盗链的问题</title>
    <link href="VickChen.win/2019/201905050112/"/>
    <id>VickChen.win/2019/201905050112/</id>
    <published>2019-05-04T17:12:01.000Z</published>
    <updated>2019-07-20T08:07:03.000Z</updated>
    
    <content type="html"><![CDATA[<p>对于不少自己搭建博客的人来说，使用什么图床可能比较难以选择，以前还有各种免费好用的图床工具，例如七牛云、SM.MS、Imgur、GitHub、微博图床等，当然还有腾讯云、阿里云的云存储服务，但是免费的意味着不稳定，说不定哪天图片就没有了，有一些国外的访问速度又不行，国内的云存储服务商价格也比较高，而且单一个博客也不需要太大空间，有点浪费。</p>
<p>本来刚刚开始写博客时用的是七牛云，后来涨价了，转到免费的 微博图床 。用了好几年没啥问题，没想到最近【2019 年 4 月份】微博图床出问题了，所有图片全部挂掉，访问图片链接全部是返回 403 状态码，表示拒绝访问，其实是微博图床开启了防盗链，本文就提供了一种简单有效的解决方案。</p>
<a id="more"></a>
<h3 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h3><p>随机抽了一些图片链接在浏览器中直接打开看，发现是可以看到图片的，然后在博客中还是看不到图片，如果在博客中选择图片链接，使用右键 在新标签页中打开 ，也是不能看到。这就说明微博图床开始检测请求的合法性了，对于不正常的请求统统拒绝。</p>
<p>当然，如果直接使用图片的链接在浏览器中单独打开，是可以看到图片的，紧接着在博客中就可以看到对应的图片了，但是这并不是说明图片可以使用了，其实是浏览器的缓存作用，如果及时清除浏览器的缓存，发现又不能使用了。</p>
<p>原来，近期微博图床对图片 CDN 添加了引用来源【Referer】检测，非微博站内引用将会返回 403 错误码，即拒绝访问。那能不能伪造或者清除这个参数呢，其实是可以的，只不过伪造、清除都需要增加一些 Javascript 动态脚本来处理，需要一些技术支持。</p>
<p>如果选择清除 Referer 参数，可以先验证一下，把图片的链接直接复制到浏览器中访问，就不会有这个参数，发现可以正常访问，没有 403 错误</p>
<h3 id="解决"><a href="#解决" class="headerlink" title="解决"></a>解决</h3><p>在静态网页的head 标记中添加如下配置项:<br><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">"referrer"</span> <span class="attr">content</span>=<span class="string">"no-referrer"</span> /&gt;</span></span><br></pre></td></tr></table></figure></p>
<p>它的作用就是阻止浏览器发送 Referer 信息，对整个页面的所有链接生效。<br>这样一来微博图床就不知道请求的引用来源了，可以达到和直接在浏览器中访问一样的效果。 但是要注意，<strong>不是每种浏览器都支持这种语法的，此设置对有的浏览器来说无效。</strong></p>
<p>那么在 Hexo 框架中怎么增加呢，显然不会有相关配置项，只能更改源代码，而且使用了 Next 主题，应该要更改主题的源代码，以保证 Hexo 在渲染静态页面为每个页面都增加这个配置。查阅文档，了解了渲染模板所在位置，打开 <strong>themes/next/layout/_partials/head.swig</strong> 文件，在里面添加 meta 标记就行。</p>
<p>修改完成后查看页面的源代码，已经有这个属性了，并且所有的图片都可以正常访问了，完美。</p>
<p>后续肯定会抽时间迁移图床的，先用着吧</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;对于不少自己搭建博客的人来说，使用什么图床可能比较难以选择，以前还有各种免费好用的图床工具，例如七牛云、SM.MS、Imgur、GitHub、微博图床等，当然还有腾讯云、阿里云的云存储服务，但是免费的意味着不稳定，说不定哪天图片就没有了，有一些国外的访问速度又不行，国内的云存储服务商价格也比较高，而且单一个博客也不需要太大空间，有点浪费。&lt;/p&gt;
&lt;p&gt;本来刚刚开始写博客时用的是七牛云，后来涨价了，转到免费的 微博图床 。用了好几年没啥问题，没想到最近【2019 年 4 月份】微博图床出问题了，所有图片全部挂掉，访问图片链接全部是返回 403 状态码，表示拒绝访问，其实是微博图床开启了防盗链，本文就提供了一种简单有效的解决方案。&lt;/p&gt;
    
    </summary>
    
      <category term="技术" scheme="VickChen.win/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="Hexo" scheme="VickChen.win/tags/Hexo/"/>
    
  </entry>
  
  <entry>
    <title>可能造成数据库索引失效的原因</title>
    <link href="VickChen.win/2019/201903210041/"/>
    <id>VickChen.win/2019/201903210041/</id>
    <published>2019-03-20T16:41:31.000Z</published>
    <updated>2020-07-19T06:05:48.250Z</updated>
    
    <content type="html"><![CDATA[<p>几乎所有的小伙伴都可以随口说几句关于创建索引的优缺点，也知道什么时候创建索引能够提高我们的查询性能，什么时候索引会更新，但是你有没有注意到，即使你设置了索引，有些时候索引他是不会生效的！这不仅考察了大家对索引的了解程度，还要让大家在使用的时候能够正确的使用。以下介绍了一些可能会造成索引失效的特殊情况，希望大家在平时开发和面试的时候能够注意到！</p>
<a id="more"></a>
<ol>
<li><p>应尽量避免在 where 子句中使用 != 或 &lt;&gt; 操作符，否则引擎将放弃使用索引而进行全表扫描；</p>
</li>
<li><p>尽量避免在 where 子句中使用 or 来连接条件，否则将导致引擎放弃使用索引而进行全表扫描，即使其中有条件带索引也不会使用，这也是为什么尽量少用 or 的原因；</p>
</li>
<li><p>对于多列索引，不是使用的第一部分，则不会使用索引；</p>
</li>
<li><p>如果列类型是字符串，那一定要在条件中将数据使用引号引用起来，否则不会使用索引；</p>
</li>
<li><p>like的模糊查询以 % 开头，索引失效；</p>
</li>
<li><p>应尽量<strong>避免</strong>在 where 子句中对字段进行<strong>表达式操作</strong>，这将导致引擎放弃使用索引而进行全表扫描；</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">--索引无效</span></span><br><span class="line"><span class="keyword">select</span> <span class="keyword">id</span> <span class="keyword">from</span> t <span class="keyword">where</span> <span class="keyword">num</span>/<span class="number">2</span> = <span class="number">100</span> </span><br><span class="line"><span class="comment">--索引有效</span></span><br><span class="line"><span class="keyword">select</span> <span class="keyword">id</span> <span class="keyword">from</span> t <span class="keyword">where</span> <span class="keyword">num</span> = <span class="number">100</span>*<span class="number">2</span>；</span><br></pre></td></tr></table></figure>
</li>
<li><p>应尽量<strong>避免</strong>在 where 子句中对字段进行<strong>函数操作</strong>，这将导致引擎放弃使用索引而进行全表扫描；</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">--索引无效</span></span><br><span class="line"><span class="keyword">select</span> <span class="keyword">id</span> <span class="keyword">from</span> t <span class="keyword">where</span> <span class="keyword">substring</span>(<span class="keyword">name</span>,<span class="number">1</span>,<span class="number">3</span>) = <span class="string">'abc'</span> – <span class="keyword">name</span>;</span><br><span class="line"><span class="comment">--以abc开头的，应改成：</span></span><br><span class="line"><span class="keyword">select</span> <span class="keyword">id</span> <span class="keyword">from</span> t <span class="keyword">where</span> <span class="keyword">name</span> <span class="keyword">like</span> ‘abc%’ </span><br><span class="line"></span><br><span class="line"><span class="comment">--索引无效</span></span><br><span class="line"><span class="keyword">select</span> <span class="keyword">id</span> <span class="keyword">from</span> t <span class="keyword">where</span> <span class="keyword">datediff</span>(<span class="keyword">day</span>, createdate, <span class="string">'2005-11-30'</span>) = <span class="number">0</span> – <span class="string">'2005-11-30'</span>;</span><br><span class="line"><span class="comment">--索引有效</span></span><br><span class="line"><span class="keyword">select</span> <span class="keyword">id</span> <span class="keyword">from</span> t <span class="keyword">where</span> createdate &gt;= <span class="string">'2005-11-30'</span> <span class="keyword">and</span> createdate &lt; <span class="string">'2005-12-1'</span>;</span><br></pre></td></tr></table></figure>
</li>
<li><p>不要在 where 子句中的 “=” 左边进行函数、算术运算或其他表达式运算，否则系统将可能无法正确使用索引；</p>
</li>
<li><p>如果MySQL估计使用全表扫描要比使用索引快，则不使用索引；</p>
</li>
<li><p>不适合键值较少的列（重复数据较多的列）</p>
<p>假如索引列TYPE有5个键值，如果有1万条数据，那么 WHERE TYPE = 1将访问表中的2000个数据块。再加上访问索引块，一共要访问大于200个的数据块。如果全表扫描，假设10条数据一个数据块，那么只需访问1000个数据块，既然全表扫描访问的数据块少一些，肯定就不会利用索引了。</p>
</li>
</ol>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;几乎所有的小伙伴都可以随口说几句关于创建索引的优缺点，也知道什么时候创建索引能够提高我们的查询性能，什么时候索引会更新，但是你有没有注意到，即使你设置了索引，有些时候索引他是不会生效的！这不仅考察了大家对索引的了解程度，还要让大家在使用的时候能够正确的使用。以下介绍了一些可能会造成索引失效的特殊情况，希望大家在平时开发和面试的时候能够注意到！&lt;/p&gt;
    
    </summary>
    
      <category term="工具" scheme="VickChen.win/categories/%E5%B7%A5%E5%85%B7/"/>
    
    
      <category term="MySql" scheme="VickChen.win/tags/MySql/"/>
    
      <category term="SQL Server" scheme="VickChen.win/tags/SQL-Server/"/>
    
      <category term="DataBase" scheme="VickChen.win/tags/DataBase/"/>
    
  </entry>
  
  <entry>
    <title>Debian使用Docker安装redis和mysql</title>
    <link href="VickChen.win/2019/201902150122/"/>
    <id>VickChen.win/2019/201902150122/</id>
    <published>2019-02-14T17:22:01.000Z</published>
    <updated>2019-07-20T09:59:49.000Z</updated>
    
    <content type="html"><![CDATA[<p>Docker是一个简化容器中应用程序进程管理过程的应用程序。容器允许您在资源隔离的进程中运行应用程序。它们与虚拟机类似，但容器更便携，更加资源友好，并且更依赖于主机操作系统。</p>
<p>这一次，我们将在Debian 9上安装和使用Docker CE。您将安装Docker本身，并使用容器和映像。</p>
<a id="more"></a>
<h2 id="Docker"><a href="#Docker" class="headerlink" title="Docker"></a>Docker</h2><h3 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h3><p>官方Debian存储库中提供的Docker安装包可能不是最新版本。为了确保我们获得最新版本，我们将从官方Docker存储库安装Docker。为此，我们将添加一个新的包源，从Docker添加GPG密钥以确保下载有效，然后安装该包。</p>
<p>首先，更新现有的包列表：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo apt update</span><br></pre></td></tr></table></figure>
<p>接下来，安装一些允许apt使用包通过HTTPS的必备软件包：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo apt install apt-transport-https ca-certificates curl gnupg2 software-properties-common</span><br></pre></td></tr></table></figure>
<p>然后将官方Docker存储库的GPG密钥添加到您的系统：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">curl -fsSL https://download.docker.com/linux/debian/gpg | sudo apt-key add -</span><br></pre></td></tr></table></figure>
<p>将Docker存储库添加到APT源：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo add-apt-repository <span class="string">"deb [arch=amd64] https://download.docker.com/linux/debian <span class="variable">$(lsb_release -cs)</span> stable"</span></span><br></pre></td></tr></table></figure>
<p>接下来，使用新添加的repo中的Docker包更新包数据库：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo apt update</span><br></pre></td></tr></table></figure>
<p>确保您要从Docker repo而不是默认的Debian repo安装：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">apt-cache policy docker-ce</span><br></pre></td></tr></table></figure>
<p>虽然Docker的版本号可能不同，但您会看到这样的输出：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">docker-ce:</span><br><span class="line">  Installed: (none)</span><br><span class="line">  Candidate: 18.06.1~ce~3-0~debian</span><br><span class="line">  Version table:</span><br><span class="line">     18.06.1~ce~3-0~debian 500</span><br><span class="line">        500 https://download.docker.com/linux/debian stretch/stable amd64 Packages</span><br></pre></td></tr></table></figure>
<p>请注意，<code>docker-ce</code>未安装，但安装的候选者来自Debian 9（stretch）的Docker存储库。</p>
<p>最后，安装Docker：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo apt install docker-ce</span><br></pre></td></tr></table></figure>
<p>现在应该安装Docker，守护进程启动，并启用进程启动进程。检查它是否正在运行：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo systemctl status docker</span><br></pre></td></tr></table></figure>
<p>输出应类似于以下内容，表明该服务处于活动状态并正在运行：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">docker.service - Docker Application Container Engine</span><br><span class="line">   Loaded: loaded (/lib/systemd/system/docker.service; enabled; vendor preset: enabled)</span><br><span class="line">   Active: active (running) since Thu 2018-07-05 15:08:39 UTC; 2min 55s ago</span><br><span class="line">     Docs: https://docs.docker.com</span><br><span class="line">  Main PID: 21319 (dockerd)</span><br><span class="line">   CGroup: /system.slice/docker.service</span><br><span class="line">           ├─21319 /usr/bin/dockerd -H fd://</span><br><span class="line">           └─21326 docker-containerd --config /var/run/docker/containerd/containerd.toml</span><br></pre></td></tr></table></figure>
<h3 id="使用Docker镜像"><a href="#使用Docker镜像" class="headerlink" title="使用Docker镜像"></a>使用Docker镜像</h3><p>Docker容器是从Docker镜像构建的。默认情况下，Docker从Docker Hub中获取这些映像，Docker Hub是由Docker管理的Docker注册表，Docker项目背后的公司。任何人都可以在Docker Hub上托管他们的Docker镜像，因此您需要的大多数应用程序和Linux发行版都将在那里托管图像。</p>
<p>要检查您是否可以从Docker Hub访问和下载图像，请键入：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker run hello-world</span><br></pre></td></tr></table></figure>
<p>输出将指示Docker正常工作：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">Unable to find image <span class="string">'hello-world:latest'</span> locally</span><br><span class="line">latest: Pulling from library/hello-world</span><br><span class="line">9db2ca6ccae0: Pull complete</span><br><span class="line">Digest: sha256:4b8ff392a12ed9ea17784bd3c9a8b1fa3299cac44aca35a85c90c5e3c7afacdc</span><br><span class="line">Status: Downloaded newer image <span class="keyword">for</span> hello-world:latest</span><br><span class="line">​</span><br><span class="line">Hello from Docker!</span><br><span class="line">This message shows that your installation appears to be working correctly.</span><br><span class="line">...</span><br></pre></td></tr></table></figure>
<p>Docker最初无法在本地找到hello-world图像，因此它从Docker Hub下载了图像，Docker Hub是默认存储库。下载映像后，Docker从映像创建了一个容器，并在容器中执行了应用程序，显示了该消息。</p>
<h3 id="操作镜像"><a href="#操作镜像" class="headerlink" title="操作镜像"></a>操作镜像</h3><h4 id="查看本机镜像"><a href="#查看本机镜像" class="headerlink" title="查看本机镜像"></a>查看本机镜像</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">vick@debian:~$ sudo docker images</span><br><span class="line">REPOSITORY          TAG                 IMAGE ID            CREATED             SIZE</span><br><span class="line">mysql               5.7                 e47e309f72c8        9 days ago          372MB</span><br><span class="line">redis               3.2                 87856cc39862        4 months ago        76MB</span><br></pre></td></tr></table></figure>
<h4 id="查看本机运行中的容器"><a href="#查看本机运行中的容器" class="headerlink" title="查看本机运行中的容器"></a>查看本机运行中的容器</h4><p><img src="https://raw.githubusercontent.com/VickChen1992/PicRepository/master/9460f058ly1g078v22tp7j20th023ab1.jpg" alt></p>
<h4 id="查看本机所有容器"><a href="#查看本机所有容器" class="headerlink" title="查看本机所有容器"></a>查看本机所有容器</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo docker ps -a</span><br></pre></td></tr></table></figure>
<h4 id="启动某个容器"><a href="#启动某个容器" class="headerlink" title="启动某个容器"></a>启动某个容器</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo docker start XXXX <span class="comment">#XXXX可以是容器的id也可以是容器的name</span></span><br></pre></td></tr></table></figure>
<h4 id="停止某个容器"><a href="#停止某个容器" class="headerlink" title="停止某个容器"></a>停止某个容器</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo docker stop XXXX <span class="comment">#XXXX可以是容器的id也可以是容器的name</span></span><br></pre></td></tr></table></figure>
<h4 id="删除镜像"><a href="#删除镜像" class="headerlink" title="删除镜像"></a>删除镜像</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo docker rmi XXXX <span class="comment">#XXXX可以是镜像的id也可以是镜像的name</span></span><br></pre></td></tr></table></figure>
<h4 id="删除容器"><a href="#删除容器" class="headerlink" title="删除容器"></a>删除容器</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo docker rm XXXX <span class="comment">#XXXX可以是容器的id也可以是容器的name</span></span><br></pre></td></tr></table></figure>
<p>注意：</p>
<ol>
<li><p>删除前需要保证容器是停止的  stop</p>
</li>
<li><p>需要注意删除镜像和容器的命令不一样。 docker rmi ID  ,其中 容器(rm)  和 镜像(rmi)</p>
</li>
<li><p>顺序需要先删除容器再删除镜像</p>
</li>
</ol>
<h2 id="MySql"><a href="#MySql" class="headerlink" title="MySql"></a>MySql</h2><h3 id="安装-1"><a href="#安装-1" class="headerlink" title="安装"></a>安装</h3><p>搜索mysql镜像：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker search mysql</span><br></pre></td></tr></table></figure>
<p>下载mysql 5.7镜像：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker pull mysql:5.7 <span class="comment">#不带版本号默认最新</span></span><br></pre></td></tr></table></figure>
<p>启动mysql：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker run --name mysql -p 3306:3306 -v /home/vick/mysql/data:/var/lib/mysql -e MYSQL_ROOT_PASSWORD=lanhe -d mysql:5.7</span><br></pre></td></tr></table></figure>
<p>注意，这里的容器名字叫：mysql ，root用户密码是：lanhe，映射宿主机子的端口3306到容器的端口3306，</p>
<p>并且将mysql的/var/lib/mysql目录映射到/home/vick/mysql/data文件夹。</p>
<h3 id="设置可远程访问"><a href="#设置可远程访问" class="headerlink" title="设置可远程访问"></a>设置可远程访问</h3><p>进入mysql容器：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">vick@debian:~$ sudo docker <span class="built_in">exec</span> -it mysql bash</span><br><span class="line">root@943fd585094f:/<span class="comment">#</span></span><br></pre></td></tr></table></figure>
<p>在容器内登陆Mysql：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">root@943fd585094f:/<span class="comment"># mysql -uroot -p  </span></span><br><span class="line"></span><br><span class="line">Enter password: </span><br><span class="line">Welcome to the MySQL monitor.  Commands end with ; or \g.</span><br><span class="line">Your MySQL connection id is 12</span><br><span class="line">Server version: 5.7.25 MySQL Community Server (GPL)</span><br><span class="line"></span><br><span class="line">Copyright (c) 2000, 2019, Oracle and/or its affiliates. All rights reserved.</span><br><span class="line"></span><br><span class="line">Oracle is a registered trademark of Oracle Corporation and/or its</span><br><span class="line">affiliates. Other names may be trademarks of their respective</span><br><span class="line">owners.</span><br><span class="line"></span><br><span class="line">Type <span class="string">'help;'</span> or <span class="string">'\h'</span> <span class="keyword">for</span> <span class="built_in">help</span>. Type <span class="string">'\c'</span> to clear the current input statement.</span><br><span class="line"></span><br><span class="line">mysql&gt;</span><br></pre></td></tr></table></figure>
<p>查看用户信息</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; select host,user,plugin,authentication_string from mysql.user;                                                                                            </span><br><span class="line">+-----------+---------------+-----------------------+-------------------------------------------+                                                                </span><br><span class="line">| host      | user          | plugin                | authentication_string                     |</span><br><span class="line">+-----------+---------------+-----------------------+-------------------------------------------+</span><br><span class="line">| localhost | root          | mysql_native_password | *A980E23A5D33A160CCCDE9D0A4DA20115167B799 |</span><br><span class="line">| localhost | mysql.session | mysql_native_password | *THISISNOTAVALIDPASSWORDTHATCANBEUSEDHERE |</span><br><span class="line">| localhost | mysql.sys     | mysql_native_password | *THISISNOTAVALIDPASSWORDTHATCANBEUSEDHERE |</span><br><span class="line">| %         | root          | mysql_native_password | *A980E23A5D33A160CCCDE9D0A4DA20115167B799 |</span><br><span class="line">+-----------+---------------+-----------------------+-------------------------------------------+</span><br><span class="line">4 rows <span class="keyword">in</span> <span class="built_in">set</span> (0.00 sec)</span><br></pre></td></tr></table></figure>
<p>host为 % 表示不限制ip   localhost表示本机使用    plugin非mysql_native_password 则需要修改密码。</p>
<p>连接时错误提示：</p>
<p><img src="https://raw.githubusercontent.com/VickChen1992/PicRepository/master/9460f058ly1g078c9yh35j20o701f0t3.jpg" alt></p>
<p>解决方法：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; ALTER user <span class="string">'root'</span>@<span class="string">'%'</span> IDENTIFIED WITH mysql_native_password BY <span class="string">'123456'</span>;  </span><br><span class="line">Query OK, 0 rows affected (0.01 sec)  </span><br><span class="line">mysql&gt;   </span><br><span class="line">mysql&gt; FLUSH PRIVILEGES;  </span><br><span class="line">Query OK, 0 rows affected (0.01 sec)</span><br></pre></td></tr></table></figure>
<p>连接数据库：</p>
<p><img src="https://raw.githubusercontent.com/VickChen1992/PicRepository/master/9460f058ly1g0788grm0gj20fq0ilgm0.jpg" alt></p>
<p>连接成功了。</p>
<h2 id="Redis"><a href="#Redis" class="headerlink" title="Redis"></a>Redis</h2><p>安装步骤与mysql类似：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">docker search  redis</span><br><span class="line">docker pull  redis:3.2</span><br></pre></td></tr></table></figure>
<p>运行：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker run --name redis -p 6379:6379 -v /home/vick/redis/data:/data  -d redis:3.2 redis-server --appendonly yes</span><br></pre></td></tr></table></figure>
<p>命令说明：</p>
<p><code>--name redis</code> :将容器命名为redis</p>
<p><code>-p 6379:6379</code> : 将容器的6379端口映射到主机的6379端口</p>
<p><code>-v /home/vick/redis/data:/data</code> : 将主机中/home/vick/redis/data目录挂载到容器的/data</p>
<p><code>redis-server --appendonly yes</code> : 在容器执行redis-server启动命令，并打开redis持久化配置</p>
<p>连接、查看容器:</p>
<p>使用redis镜像执行redis-cli命令连接到刚启动的容器,主机IP为172.17.0.1</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">vick@debian:~$ sudo docker <span class="built_in">exec</span> -it redis redis-cli</span><br><span class="line">127.0.0.1:6379&gt; info</span><br><span class="line"><span class="comment"># Server</span></span><br><span class="line">redis_version:3.2.12</span><br><span class="line">redis_git_sha1:00000000</span><br><span class="line">redis_git_dirty:0</span><br><span class="line">redis_build_id:b0df607ad3315254</span><br><span class="line">redis_mode:standalone</span><br><span class="line">os:Linux 4.9.0-8-amd64 x86_64</span><br><span class="line">arch_bits:64</span><br><span class="line">multiplexing_api:epoll</span><br><span class="line">gcc_version:6.3.0</span><br><span class="line">process_id:1</span><br><span class="line">run_id:54ef1808535f61b18b9713cd9455c09396f032b4</span><br><span class="line">tcp_port:6379</span><br><span class="line">uptime_in_seconds:5065</span><br><span class="line">uptime_in_days:0</span><br><span class="line">hz:10</span><br><span class="line">lru_clock:6719318</span><br><span class="line">executable:/data/redis-server</span><br><span class="line">config_file:</span><br><span class="line"></span><br><span class="line"><span class="comment"># Clients</span></span><br><span class="line">connected_clients:1</span><br><span class="line">client_longest_output_list:0</span><br><span class="line">client_biggest_input_buf:0</span><br><span class="line">blocked_clients:0</span><br><span class="line">...</span><br></pre></td></tr></table></figure>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Docker是一个简化容器中应用程序进程管理过程的应用程序。容器允许您在资源隔离的进程中运行应用程序。它们与虚拟机类似，但容器更便携，更加资源友好，并且更依赖于主机操作系统。&lt;/p&gt;
&lt;p&gt;这一次，我们将在Debian 9上安装和使用Docker CE。您将安装Docker本身，并使用容器和映像。&lt;/p&gt;
    
    </summary>
    
      <category term="技术" scheme="VickChen.win/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="Linux" scheme="VickChen.win/tags/Linux/"/>
    
      <category term="Redis" scheme="VickChen.win/tags/Redis/"/>
    
      <category term="Debian" scheme="VickChen.win/tags/Debian/"/>
    
      <category term="Docker" scheme="VickChen.win/tags/Docker/"/>
    
      <category term="MySql" scheme="VickChen.win/tags/MySql/"/>
    
  </entry>
  
  <entry>
    <title>Debian 安装 Redis、MySql</title>
    <link href="VickChen.win/2019/201901221340/"/>
    <id>VickChen.win/2019/201901221340/</id>
    <published>2019-01-22T05:40:32.000Z</published>
    <updated>2019-07-26T03:00:28.000Z</updated>
    
    <content type="html"><![CDATA[<p>项目中需要用到的数据库安装、配置以及常见错误</p>
<a id="more"></a>
<h2 id="Redis"><a href="#Redis" class="headerlink" title="Redis"></a>Redis</h2><p>Redis 是一个高性能的key-value数据库。 在部分场合可以对关系数据库起到很好的补充作用。是当前比较热门的NOSQL系统之一。它提供了C#，Java，PHP，JavaScript，Python，Ruby等客户端，使用很方便。</p>
<h3 id="下载并解压"><a href="#下载并解压" class="headerlink" title="下载并解压"></a>下载并解压</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 跳转至目录</span></span><br><span class="line"><span class="built_in">cd</span> /usr/<span class="built_in">local</span>/src</span><br><span class="line"><span class="comment"># 下载</span></span><br><span class="line">wget http://download.redis.io/releases/redis-stable.tar.gz</span><br><span class="line"><span class="comment"># 解压</span></span><br><span class="line">tar xzf redis-stable.tar.gz</span><br></pre></td></tr></table></figure>
<h3 id="编译"><a href="#编译" class="headerlink" title="编译"></a>编译</h3><p>Redis基于C开发，因此确保电脑安装有gcc和make。</p>
<ol>
<li>安装make命令  <code>sudo apt-get install make</code></li>
<li>安装sysv-rc-conf命令  <code>sudo apt-get install sysv-rc-conf</code></li>
<li>安装GCC:  <code>sudo apt-get install gcc</code></li>
</ol>
<p>完成之后，编译步骤如下：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cd</span> redis-stable</span><br><span class="line">make <span class="built_in">test</span> <span class="comment"># 可忽略，测试主机性能</span></span><br><span class="line">make</span><br><span class="line">sudo make install</span><br><span class="line">sudo ./install_server.sh</span><br></pre></td></tr></table></figure>
<h3 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h3><p>接下来会出来redis配置，按照提示一步步设置端口，日志路径，配置文件等。<br>系统服务位于/etc/init.d/redis_6379，可以更名为/etc/inti.d/reids-server.</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">sudo mv /etc/init.d/redis&#123;_6379,-server&#125;</span><br><span class="line"><span class="comment"># 启动：</span></span><br><span class="line">sudo redis-server</span><br><span class="line"><span class="comment">#关闭命令-建议使用客户端停止</span></span><br><span class="line">redis-cli shutdown</span><br></pre></td></tr></table></figure>
<h3 id="测试和连接"><a href="#测试和连接" class="headerlink" title="测试和连接"></a>测试和连接</h3><p>使用redis客户端测试服务器</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">redis-cli ping</span><br><span class="line">PONG</span><br></pre></td></tr></table></figure>
<h3 id="修改Redis配置"><a href="#修改Redis配置" class="headerlink" title="修改Redis配置"></a>修改Redis配置</h3><h4 id="设置访问账号"><a href="#设置访问账号" class="headerlink" title="设置访问账号"></a>设置访问账号</h4><p>默认情况下，访问Redis服务器是不需要密码的，为了增加安全性我们需要设置Redis服务器的访问密码。设置访问密码为password。</p>
<p>用vi打开Redis服务器的配置文件redis.conf</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">sudo vi /etc/redis/redis.conf</span><br><span class="line"><span class="comment">#取消注释requirepass</span></span><br><span class="line">requirepass password</span><br></pre></td></tr></table></figure>
<h4 id="设置Redis可被远程访问"><a href="#设置Redis可被远程访问" class="headerlink" title="设置Redis可被远程访问"></a>设置Redis可被远程访问</h4><p>默认情况下，Redis服务器不允许远程访问，只允许本机访问，所以我们需要设置打开远程访问的功能。用vi打开Redis服务器的配置文件redis.conf </p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">sudo vi /etc/redis/redis.conf</span><br><span class="line"><span class="comment">#注释bind</span></span><br><span class="line"><span class="comment">#bind 127.0.0.1</span></span><br></pre></td></tr></table></figure>
<p>修改后，重启Redis服务器</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">redis-cli shutdown</span><br><span class="line">sudo redis-server</span><br></pre></td></tr></table></figure>
<h3 id="登陆"><a href="#登陆" class="headerlink" title="登陆"></a>登陆</h3><p>本机登陆Redis服务器，输入密码</p>
<p><code>redis-cli -a password</code></p>
<p>远程访问，主机为x.x.x.x</p>
<p><code>redis-cli -a password -h x.x.x.x</code></p>
<h2 id="MySql"><a href="#MySql" class="headerlink" title="MySql"></a>MySql</h2><p>MySql是目前最受欢迎的关系型数据库之一。 由于其体积小、速度快、总体拥有成本低，尤其是开放源码这一特点，很多中小型网站的开发都选择将 MySql作为网站数据库。</p>
<h3 id="配置源"><a href="#配置源" class="headerlink" title="配置源"></a>配置源</h3><p>debian下安装软件的指令为apt-get，在使用apt-get安装之前，需要先下载官网提供的Deb包，以将MySql的仓库添加到apt-get的源中。</p>
<ol>
<li><p>获取下载链接</p>
<p>打开网站<a href="https://link.jianshu.com/?t=https%3A%2F%2Fdev.mysql.com%2Fdownloads%2Frepo%2Fapt%2F" target="_blank" rel="noopener">MySQL APT Respository</a></p>
<p><img src="https://raw.githubusercontent.com/VickChen1992/PicRepository/master/9460f058ly1fzgaj3o70yj20s005fjrp.jpg" alt></p>
</li>
<li><p>点击Download，跳转到下载页面</p>
<p><img src="https://raw.githubusercontent.com/VickChen1992/PicRepository/master/9460f058ly1fzgalkchhrj20ob0gsabk.jpg" alt></p>
</li>
<li><p>右键点击No thanks，just start my download复制链接</p>
</li>
<li><p>进入工作目录</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cd</span> ~</span><br></pre></td></tr></table></figure>
</li>
<li><p>下载Deb文件</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">wget https://dev.mysql.com/get/mysql-apt-config_0.8.12-1_all.deb</span><br></pre></td></tr></table></figure>
</li>
<li><p>将该文件添加至apt-get的源</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo dpkg -i ./mysql-apt-config_0.8.12-1_all.deb</span><br></pre></td></tr></table></figure>
</li>
<li><p>然后会弹出MySql的源配置界面</p>
<p><img src="https://raw.githubusercontent.com/VickChen1992/PicRepository/master/9460f058ly1fzgaf3wc54j20rs0d447p.jpg" alt></p>
<p>我们仅需选择版本，下面两个选项默认即可</p>
</li>
<li><p>更新源</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo apt-get update</span><br></pre></td></tr></table></figure>
</li>
</ol>
<h3 id="安装-1"><a href="#安装-1" class="headerlink" title="安装"></a>安装</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo apt-get install mysql-server</span><br></pre></td></tr></table></figure>
<p>这一步可能会提示错误:</p>
<p><img src="https://raw.githubusercontent.com/VickChen1992/PicRepository/master/9460f058gy1fzgav214e7j20h504pmz9.jpg" alt></p>
<p>可以换个命令</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo aptitude install &lt;mysql-server&gt;</span><br></pre></td></tr></table></figure>
<p>因为<code>aptitude</code>会自动把所有依赖的库都帮你顺着找到，并下载好。</p>
<p>而<code>apt-get</code>下载某个包中它的所有依赖项都必须存在。</p>
<p>这就是为什么我们每次执行<code>apt-get</code>的时候都需要先<code>apt-get update</code>的更新软件包的原因。</p>
<p>如果提示找不到<code>aptitude</code>，可以先使用<code>sudo apt-get install aptitude</code>进行下载</p>
<p>然后就是漫长的等待，因为安装包200多M…..</p>
<p>中途会让你输入root密码，自己输入一个记住就行了。</p>
<h3 id="基本操作"><a href="#基本操作" class="headerlink" title="基本操作"></a>基本操作</h3><ol>
<li><p>开启MySql服务</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo service mysql start</span><br></pre></td></tr></table></figure>
</li>
<li><p>关闭服务</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo service mysql stop</span><br></pre></td></tr></table></figure>
</li>
<li><p>重启服务</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo service mysql restart</span><br></pre></td></tr></table></figure>
</li>
<li><p>登陆</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mysql -u root -p</span><br></pre></td></tr></table></figure>
<p>输入密码即可登陆</p>
</li>
<li><p>指定端口号登录</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mysql -u root -p -P 3306</span><br></pre></td></tr></table></figure>
<p>注意指定端口的字母P为大写，而标识密码的p为小写。MySql默认端口号为3306</p>
</li>
<li><p>指定IP地址和端口号登录MySQL数据库</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mysql -h 127.0.0.1 -u root -p -P 3306</span><br></pre></td></tr></table></figure>
</li>
</ol>
<h3 id="配置"><a href="#配置" class="headerlink" title="配置"></a>配置</h3><p>因为MySql刚安装完成不允许从远程访问而且只有一个root用户，这对于开发不太友好也比较不安全。</p>
<p>所以我们应该创建一个用于开发的数据库账户，并且为它设置远程访问权限。</p>
<p>当然，<strong>在真正投入生成环境之后，我们应该移除远程访问的权限</strong></p>
<ol>
<li><p>登录MySql</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mysql -u root -p</span><br></pre></td></tr></table></figure>
</li>
<li><p>输入密码登录之后，新建一个用户</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; CREATE USER <span class="string">'username'</span>@<span class="string">'%'</span> IDENTIFIED BY <span class="string">'password'</span>;</span><br></pre></td></tr></table></figure>
</li>
<li><p>完成之后为该用户分配所有权限</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; GRANT ALL PRIVILEGES ON *.* TO <span class="string">'username'</span>@<span class="string">'%'</span>;</span><br></pre></td></tr></table></figure>
</li>
<li><p>接着刷新权限即可使用新用户在任意host登录数据库</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; FLUSH PRIVILEGES;</span><br></pre></td></tr></table></figure>
</li>
<li><p>如果还是不行的话，打开下面的文件</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo vim /etc/mysql/mysql.conf.d/mysqld.cnf</span><br></pre></td></tr></table></figure>
</li>
<li><p>把bind-adress那一行的127.0.0.1改成0.0.0.0 </p>
<p><strong>重要提示：投入生产时记得改回来</strong></p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># By default we only accept connections from localhost</span></span><br><span class="line"><span class="comment"># bind-address    = 127.0.0.1 #先注释此行</span></span><br><span class="line"><span class="built_in">bind</span>-address    = 0.0.0.0</span><br></pre></td></tr></table></figure>
</li>
</ol>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;项目中需要用到的数据库安装、配置以及常见错误&lt;/p&gt;
    
    </summary>
    
      <category term="技术" scheme="VickChen.win/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="Linux" scheme="VickChen.win/tags/Linux/"/>
    
      <category term="Redis" scheme="VickChen.win/tags/Redis/"/>
    
      <category term="Debian" scheme="VickChen.win/tags/Debian/"/>
    
      <category term="MySql" scheme="VickChen.win/tags/MySql/"/>
    
  </entry>
  
  <entry>
    <title>Debian 安装 VMware Tools</title>
    <link href="VickChen.win/2018/201812240020/"/>
    <id>VickChen.win/2018/201812240020/</id>
    <published>2018-12-23T16:20:11.000Z</published>
    <updated>2019-07-20T08:06:36.000Z</updated>
    
    <content type="html"><![CDATA[<p>VMware Tools是VMware虚拟机中自带的一种增强工具，相当于VirtualBox中的增强功能（Sun VirtualBox Guest Additions），是VMware提供的增强虚拟显卡和硬盘性能、以及同步虚拟机与主机时钟的驱动程序。</p>
<a id="more"></a>
<h3 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h3><p>首先选择VMware导航栏的 虚拟机&gt;安装VMware Tools</p>
<p>之后打开  文件&gt;VMware Tools</p>
<p>将VMwareTools.tar.gz文件复制至home目录下</p>
<p>打开home文件中打开命令行,利用tar -zxvf解压VMwareTools.tar.gz</p>
<p><code>tar zxvf VMwareTools.tar.gz</code></p>
<p>将会得到VMware-Tools-distrib文件夹</p>
<p>然后将VMware-Tools-distrib放至/usr/src目录</p>
<p>sudo cp -r /home/vick/VMware-Tools-distrib /usr/src/</p>
<p>因为debian默认并没有带有ifconfig命令,因此在安装VMware Tools前需要安装net-tools</p>
<p>安装net-tools</p>
<p><code>sudo apt-get install net-tools</code></p>
<p>开始安装VMwareTools</p>
<p><code>sudo /usr/src/VMware-Tools-distrib/vmware-install.pl</code></p>
<p>之后一直按回车键,直到安装完成后重启</p>
<h3 id="常见问题"><a href="#常见问题" class="headerlink" title="常见问题"></a>常见问题</h3><ol>
<li><p>debian 9解决安装vm tools 不生效</p>
<p><code>apt install open-vm-tools open-vm-tools-desktop open-vm-tools-dkmsb</code></p>
</li>
<li><p>卸载</p>
<p>查找其卸载程序位置</p>
<p><code>find / ./vmware-uninstall-tools.pl</code></p>
<p>一般是在/usr/bin/目录下，找到后在其所在目录执行它。</p>
<p><code>./vmware-uninstall-tools.pl</code></p>
<p>完全删除其配置文件命令如下(请谨慎使用，勿敲错！数据无价，本人概不负责)。</p>
<p><code>find / vmware*  -exec rm -rfv {} \;</code></p>
</li>
</ol>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;VMware Tools是VMware虚拟机中自带的一种增强工具，相当于VirtualBox中的增强功能（Sun VirtualBox Guest Additions），是VMware提供的增强虚拟显卡和硬盘性能、以及同步虚拟机与主机时钟的驱动程序。&lt;/p&gt;
    
    </summary>
    
      <category term="技术" scheme="VickChen.win/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="Linux" scheme="VickChen.win/tags/Linux/"/>
    
      <category term="Debian" scheme="VickChen.win/tags/Debian/"/>
    
      <category term="VMware" scheme="VickChen.win/tags/VMware/"/>
    
  </entry>
  
  <entry>
    <title>使用Debian时遇到的问题</title>
    <link href="VickChen.win/2018/201812200110/"/>
    <id>VickChen.win/2018/201812200110/</id>
    <published>2018-12-19T17:10:05.000Z</published>
    <updated>2019-07-26T02:59:04.000Z</updated>
    
    <content type="html"><![CDATA[<p>目前在学习Debian，然后发现一路都是坑，与之前接触的Ubuntu在使用上还是有点差别的。Debian更加原生，也更加稳定，坑也更多。为了防止后来者继续踩坑，特意写了此文用于记录总结初学者在学习过程中遇到的各种问题。</p>
<a id="more"></a>
<h2 id="切换系统语言环境"><a href="#切换系统语言环境" class="headerlink" title="切换系统语言环境"></a>切换系统语言环境</h2><p>在Debian系统中，若是设置了中文环境后，在终端进行操作时，将会遇到中文错误提示等信息显示为乱码的问题。这时候，部分朋友选择了重新安装系统。然而，其实并不用重新安装，只要进行语言的切换就可以了。</p>
<p>命令行执行：</p>
<p><code>$ sudo dpkg-reconfigure locales</code></p>
<p>将打开一个选择语言的窗口，在此窗口中选择英文环境的字符集项，此例中选择en_US.utf-8，即按空格选中复选框，将中文环境的包 (<code>zh_CN.utf-8</code>) ，将复选框去掉选择后敲回车，确定安装即可。</p>
<p>可使用以下命令查看是否安装成功：</p>
<p><code>$ locale -a</code></p>
<p>系统将输出如下内容：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">C</span><br><span class="line">C.UTF-8</span><br><span class="line">POSIX</span><br><span class="line">en_US.UTF-8</span><br></pre></td></tr></table></figure>
<p>然后输入<code>$ reboot</code> 重启系统即可。</p>
<p>若是担心英文环境下操作不方便也可切换为繁体中文(<code>zh_HK.utf-8</code>)</p>
<h2 id="gedit找不到命令"><a href="#gedit找不到命令" class="headerlink" title="gedit找不到命令"></a>gedit找不到命令</h2><p>直接重装下gedit即可。</p>
<p>打开终端，输入代码：</p>
<p><code>sudo apt-get  remove gedit</code></p>
<p>回车后输入：</p>
<p><code>sudo apt-get install gedit</code></p>
<h2 id="中文输入法不可用"><a href="#中文输入法不可用" class="headerlink" title="中文输入法不可用"></a>中文输入法不可用</h2><p>系统刚刚装好后随即安装了fcitx-googlepinyin输入法，发现输入法各种ctrl+space或者ctrl+shift一通乱按就是什么也看不到，几经折腾发现是因为根本就没有Ui控件…</p>
<p>还需要安装输入法前端所需要的ui动态库</p>
<p>打开终端，输入：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">apt-get install fcitx-ui-classic &amp;&amp; apt-get install fcitx-ui-light</span><br></pre></td></tr></table></figure>
<p>安装完成后打开fcitx的配置工具，根据需要删除掉不需要的输入法。</p>
<p>然后<code>reboot</code> 重启系统，就可以看到按下快捷键后输入法弹出来了。然而这里又有一个坑，因为 <strong>输入法默认字号是零</strong> ，记得在Appearance页签内重新设置字号。</p>
<h2 id="更新163源"><a href="#更新163源" class="headerlink" title="更新163源"></a>更新163源</h2><p>终端输入：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gedit /etc/apt/sources.list</span><br></pre></td></tr></table></figure>
<p>复制以下内容保存即可</p>
<blockquote>
<p> deb <a href="http://mirrors.163.com/debian/" target="_blank" rel="noopener">http://mirrors.163.com/debian/</a> stretch main non-free contrib<br> deb <a href="http://mirrors.163.com/debian/" target="_blank" rel="noopener">http://mirrors.163.com/debian/</a> stretch-updates main non-free contrib<br> deb <a href="http://mirrors.163.com/debian/" target="_blank" rel="noopener">http://mirrors.163.com/debian/</a> stretch-backports main non-free contrib<br> deb-src <a href="http://mirrors.163.com/debian/" target="_blank" rel="noopener">http://mirrors.163.com/debian/</a> stretch main non-free contrib<br> deb-src <a href="http://mirrors.163.com/debian/" target="_blank" rel="noopener">http://mirrors.163.com/debian/</a> stretch-updates main non-free contrib<br> deb-src <a href="http://mirrors.163.com/debian/" target="_blank" rel="noopener">http://mirrors.163.com/debian/</a> stretch-backports main non-free contrib<br> deb <a href="http://mirrors.163.com/debian-security/" target="_blank" rel="noopener">http://mirrors.163.com/debian-security/</a> stretch/updates main non-free contrib<br> deb-src <a href="http://mirrors.163.com/debian-security/" target="_blank" rel="noopener">http://mirrors.163.com/debian-security/</a> stretch/updates main non-free contrib</p>
</blockquote>
<p>直接保存即可</p>
<p>然后运行下面的命令用于更新配置</p>
<p><code>apt-get update</code></p>
<h2 id="切换系统用户"><a href="#切换系统用户" class="headerlink" title="切换系统用户"></a>切换系统用户</h2><p>更新源的时候可能会遇到无法保存的问题，是因为这个权限不够，这时候有两个办法。</p>
<p>这里先说第一个办法，切换系统用户到root后再执行上述命令。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">su root</span><br></pre></td></tr></table></figure>
<p>然后会让你输入root用户密码，此处密码无输入效果。输入后按回车即可。</p>
<p>然后就可以看到看到系统用户已经成功改为root最高权限用户了。</p>
<p>以此类推，切换回原来用户只需要再执行一遍<code>su username</code> 指令后输入该用户对应的密码即可。</p>
<p>另外，<code>sudo su</code> 指令同样可以切换用户。但是可能会报下面的错误</p>
<h2 id="sudo指令报错"><a href="#sudo指令报错" class="headerlink" title="sudo指令报错"></a>sudo指令报错</h2><p>上面说的另一个办法就是在语句前加sudo 用临时权限执行。</p>
<p>初次使用这个指令可能会报错：</p>
<blockquote>
<p>当前用户不在sudoers文件(/etc/sudoers)里面，直接使用sudo命令是不允许的，会被系统记录并向root反馈</p>
</blockquote>
<p>处理这个问题很简单，但应该先理解其原理再操作。<br>首先要明白root的密码一般用户是不应改知道的，但一般用户有时可能要用到root的一些权限。<br>这里就有了一个 /etc/sudoers 文件，用来保存一些用户，使这些用户可以通过sudo命令来暂时获取root的权限。这些用户使用sudo时输入的密码是当前用户密码，而不是root密码。还可一在sudoers文件里限制一般用户的权限，这样就有了安全保证。</p>
<p>那么我们就来解决这个问题：</p>
<ol>
<li><p>切换到root用户</p>
<p><code>$ su root</code></p>
</li>
<li><p>查看/etc/sudoers权限</p>
<p><code>$ ls -all /etc/sudoers</code></p>
</li>
<li><p>更改权限为777</p>
<p><code>$ chmod 777 /etc/sudoers</code></p>
</li>
<li><p>编辑/etc/sudoers</p>
<p><code>$ vi /etc/sudoers</code></p>
<p>这个命令的意思是使用vi编辑器打开文件。</p>
</li>
<li><p>添加当前用户</p>
<p>可以看到打开的文件内容为：</p>
<blockquote>
<p>root ALL=(ALL:ALL) ALL</p>
</blockquote>
<p>在后面追加一行</p>
<blockquote>
<p>vick ALL=(ALL:ALL) ALL</p>
</blockquote>
<p>vi中刚进去是命令模式 按 <code>i</code> 或者 <code>insert</code> 进入编辑模式，编辑完了之后按ctrl+c或者esc退出编辑模式。之后输入命令 <code>:wq</code> ，保存离开。</p>
</li>
<li><p>把/etc/sudoers权限改回原来数据</p>
<p><code>$ chmod 690 /etc/sudoers</code></p>
</li>
</ol>
<p><strong>这里也可以不查看及修改权限，直接用root用户打开并修改文件后，使用<code>:wq!</code> 指令强制保存并离开。不过最好重新打开看下有没有保存成功</strong></p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;目前在学习Debian，然后发现一路都是坑，与之前接触的Ubuntu在使用上还是有点差别的。Debian更加原生，也更加稳定，坑也更多。为了防止后来者继续踩坑，特意写了此文用于记录总结初学者在学习过程中遇到的各种问题。&lt;/p&gt;
    
    </summary>
    
      <category term="技术" scheme="VickChen.win/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="Linux" scheme="VickChen.win/tags/Linux/"/>
    
      <category term="Debian" scheme="VickChen.win/tags/Debian/"/>
    
  </entry>
  
  <entry>
    <title>.Net Core使用mailkit收取和发送邮件</title>
    <link href="VickChen.win/2018/201811230212/"/>
    <id>VickChen.win/2018/201811230212/</id>
    <published>2018-11-22T18:12:00.000Z</published>
    <updated>2019-07-26T02:57:43.000Z</updated>
    
    <content type="html"><![CDATA[<p>邮件服务是一般的系统都会拥有和需要的功能，但是对于.Net项目来说，邮件服务的创建和使用会较为的麻烦。.NET对于邮件功能提供了System.Net.Mail用于创建邮件服务，该基础服务提供邮件的基础操作，并且使用也较为的简单。对于真正将该功能使用于项目的人，就会慢慢发现其中的优缺点，甚至有些时候不能忍受其中的问题。在这里介绍一种微软用于替代System.Net.Mail的邮件服务组件MailKit和MimeKit，官网地址：<a href="http://www.mimekit.net/" target="_blank" rel="noopener">http://www.mimekit.net/</a> GitHub地址：<a href="https://github.com/jstedfast/MimeKit" target="_blank" rel="noopener">https://github.com/jstedfast/MimeKit</a></p>
<a id="more"></a>
<h2 id="MailKit和MimeKit基础概述"><a href="#MailKit和MimeKit基础概述" class="headerlink" title="MailKit和MimeKit基础概述"></a>MailKit和MimeKit基础概述</h2><p>MailKit组件是一个免费开源的邮箱类库，简单来说MailKit帮我们封装了有关邮箱的一些帮助类，提供方法让我们更容易使用邮箱的SMTP、POP3、IMAP等协议。该组件是一个跨平台的Email组件，该组件支持.Net Core 、.Net FrameWork、Xamarin.Android、Xamarin.iOS、Windows Phone等等平台。</p>
<p>MimeKit提供了一个MIME解析器，组件具备的解析特性灵活、性能高、很好的处理各种各样的破碎的MIME格式化。MimeKit的性能实际上与GMime相当。</p>
<p>该组件在安全性的还是比较高的，处理安全的方式较多，SASL认证、支持S / MIME v3.2、支持OpenPGP、支持DKIM签名等等方式。Mailkit组件可以通过CancellationToken取消对应的操作，CancellationToken传播应取消操作的通知，一个的CancellationToken使线程，线程池工作项目之间，或取消合作任务的对象。过实例化CancellationTokenSource对象来创建取消令牌，该对象管理从其CancellationTokenSource.Token属性检索的取消令牌。然后，将取消令牌传递到应该收到取消通知的任意数量的线程，任务或操作。令牌不能用于启动取消。<br> MailKit组件支持异步操作，在内部编写的有关I/O异步操作的类</p>
<h2 id="创建基础邮件服务"><a href="#创建基础邮件服务" class="headerlink" title="创建基础邮件服务"></a>创建基础邮件服务</h2><p>介绍过MailKit和MimeKit组建的基础信息，接下来就介绍一下如何使用两个组件的基本功能，在这里我将基本操作做了一个简单的封装，一般的项目可以直接引用封装好的类，大家可以根据实际的情况对该组件进行扩展。</p>
<h3 id="基础实体类"><a href="#基础实体类" class="headerlink" title="基础实体类"></a>基础实体类</h3><h4 id="邮件实体类"><a href="#邮件实体类" class="headerlink" title="邮件实体类"></a>邮件实体类</h4><p>用于保存邮件至数据库</p>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">MailBoxEntity</span> : <span class="title">BaseEntity</span> &#123;</span><br><span class="line">    <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;summary&gt;</span></span></span><br><span class="line">    <span class="comment"><span class="doctag">///</span> 该邮件所属邮箱账号</span></span><br><span class="line">    <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;/summary&gt;</span></span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span> OwnerMailAccount &#123; <span class="keyword">get</span>; <span class="keyword">set</span>; &#125;</span><br><span class="line">    <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;summary&gt;</span></span></span><br><span class="line">    <span class="comment"><span class="doctag">///</span> 邮件主题</span></span><br><span class="line">    <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;/summary&gt;</span></span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">string</span> Subject &#123; <span class="keyword">get</span>; <span class="keyword">set</span>; &#125;</span><br><span class="line">    <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;summary&gt;</span></span></span><br><span class="line">    <span class="comment"><span class="doctag">///</span> 邮件文本内容</span></span><br><span class="line">    <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;/summary&gt;</span></span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">string</span> MailTextBody &#123; <span class="keyword">get</span>; <span class="keyword">set</span>; &#125; = <span class="string">""</span>;</span><br><span class="line">    <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;summary&gt;</span></span></span><br><span class="line">    <span class="comment"><span class="doctag">///</span> 邮件html内容</span></span><br><span class="line">    <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;/summary&gt;</span></span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">string</span> MailHtmlBody &#123; <span class="keyword">get</span>; <span class="keyword">set</span>; &#125; = <span class="string">""</span>;</span><br><span class="line">    <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;summary&gt;</span></span></span><br><span class="line">    <span class="comment"><span class="doctag">///</span> 邮件内容类型</span></span><br><span class="line">    <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;/summary&gt;</span></span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">string</span> MailBodyType &#123; <span class="keyword">get</span>; <span class="keyword">set</span>; &#125; = <span class="string">"html"</span>;</span><br><span class="line">    <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;summary&gt;</span></span></span><br><span class="line">    <span class="comment"><span class="doctag">///</span> 邮件附件文件路径</span></span><br><span class="line">    <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;/summary&gt;</span></span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">string</span> MailFilePath &#123; <span class="keyword">get</span>; <span class="keyword">set</span>; &#125;</span><br><span class="line">    <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;summary&gt;</span></span></span><br><span class="line">    <span class="comment"><span class="doctag">///</span> 收件人地址</span></span><br><span class="line">    <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;/summary&gt;</span></span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">string</span> Recipients &#123; <span class="keyword">get</span>; <span class="keyword">set</span>; &#125;</span><br><span class="line">    <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;summary&gt;</span></span></span><br><span class="line">    <span class="comment"><span class="doctag">///</span> 收件人名字</span></span><br><span class="line">    <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;/summary&gt;</span></span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">string</span> RecipientsName &#123; <span class="keyword">get</span>; <span class="keyword">set</span>; &#125;</span><br><span class="line">    <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;summary&gt;</span></span></span><br><span class="line">    <span class="comment"><span class="doctag">///</span> 抄送</span></span><br><span class="line">    <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;/summary&gt;</span></span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">string</span> Cc &#123; <span class="keyword">get</span>; <span class="keyword">set</span>; &#125;</span><br><span class="line">    <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;summary&gt;</span></span></span><br><span class="line">    <span class="comment"><span class="doctag">///</span> 密送</span></span><br><span class="line">    <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;/summary&gt;</span></span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">string</span> Bcc &#123; <span class="keyword">get</span>; <span class="keyword">set</span>; &#125;</span><br><span class="line">    <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;summary&gt;</span></span></span><br><span class="line">    <span class="comment"><span class="doctag">///</span> 发件人</span></span><br><span class="line">    <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;/summary&gt;</span></span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">string</span> Sender &#123; <span class="keyword">get</span>; <span class="keyword">set</span>; &#125; = <span class="string">""</span>;</span><br><span class="line">    <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;summary&gt;</span></span></span><br><span class="line">    <span class="comment"><span class="doctag">///</span> 发件人地址</span></span><br><span class="line">    <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;/summary&gt;</span></span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">string</span> SenderAddress &#123; <span class="keyword">get</span>; <span class="keyword">set</span>; &#125;</span><br><span class="line">    <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;summary&gt;</span></span></span><br><span class="line">    <span class="comment"><span class="doctag">///</span> 邮件类型</span></span><br><span class="line">    <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;/summary&gt;</span></span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span> MailType &#123; <span class="keyword">get</span>; <span class="keyword">set</span>; &#125;</span><br><span class="line">    <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;summary&gt;</span></span></span><br><span class="line">    <span class="comment"><span class="doctag">///</span> 收件/发件时间</span></span><br><span class="line">    <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;/summary&gt;</span></span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">string</span> Date &#123; <span class="keyword">get</span>; <span class="keyword">set</span>; &#125;</span><br><span class="line">    <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;summary&gt;</span></span></span><br><span class="line">    <span class="comment"><span class="doctag">///</span> 邮件标识</span></span><br><span class="line">    <span class="comment"><span class="doctag">///</span> 是否已读，是否回复，是否删除</span></span><br><span class="line">    <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;/summary&gt;</span></span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">bool</span> Flag &#123; <span class="keyword">get</span>; <span class="keyword">set</span>; &#125;</span><br><span class="line">    <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;summary&gt;</span></span></span><br><span class="line">    <span class="comment"><span class="doctag">///</span> 是否已读</span></span><br><span class="line">    <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;/summary&gt;</span></span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">bool</span> IsRead &#123; <span class="keyword">get</span>; <span class="keyword">set</span>; &#125;</span><br><span class="line">    <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;summary&gt;</span></span></span><br><span class="line">    <span class="comment"><span class="doctag">///</span> 是否已经回复</span></span><br><span class="line">    <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;/summary&gt;</span></span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">bool</span> IsAnswered &#123; <span class="keyword">get</span>; <span class="keyword">set</span>; &#125;</span><br><span class="line">    <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;summary&gt;</span></span></span><br><span class="line">    <span class="comment"><span class="doctag">///</span> 邮件唯一标识</span></span><br><span class="line">    <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;/summary&gt;</span></span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">string</span> MessageId &#123; <span class="keyword">get</span>; <span class="keyword">set</span>; &#125;</span><br><span class="line">    <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;summary&gt;</span></span></span><br><span class="line">    <span class="comment"><span class="doctag">///</span> 邮件唯一查询标识</span></span><br><span class="line">    <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;/summary&gt;</span></span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">uint</span>? UniqueId &#123; <span class="keyword">get</span>; <span class="keyword">set</span>; &#125;</span><br><span class="line">    <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;summary&gt;</span></span></span><br><span class="line">    <span class="comment"><span class="doctag">///</span> 引用邮件唯一标识</span></span><br><span class="line">    <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;/summary&gt;</span></span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">string</span> References &#123; <span class="keyword">get</span>; <span class="keyword">set</span>; &#125;</span><br><span class="line">    <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;summary&gt;</span></span></span><br><span class="line">    <span class="comment"><span class="doctag">///</span> 邮件所属邮箱服务器的文件夹标识</span></span><br><span class="line">    <span class="comment"><span class="doctag">///</span> inbox(收件箱),</span></span><br><span class="line">    <span class="comment"><span class="doctag">///</span> archive(档案箱),</span></span><br><span class="line">    <span class="comment"><span class="doctag">///</span> drafts(草稿箱),</span></span><br><span class="line">    <span class="comment"><span class="doctag">///</span> flagged(标记的),</span></span><br><span class="line">    <span class="comment"><span class="doctag">///</span> junk(垃圾箱),</span></span><br><span class="line">    <span class="comment"><span class="doctag">///</span> sent(发件箱),</span></span><br><span class="line">    <span class="comment"><span class="doctag">///</span> trash(回收箱)</span></span><br><span class="line">    <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;/summary&gt;</span></span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">string</span> FolderType &#123; <span class="keyword">get</span>; <span class="keyword">set</span>; &#125; = <span class="string">""</span>;</span><br><span class="line">    <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;summary&gt;</span></span></span><br><span class="line">    <span class="comment"><span class="doctag">///</span> 文件夹名称</span></span><br><span class="line">    <span class="comment"><span class="doctag">///</span> 一般用于区别Inbox文件夹下用户自定义的文件夹</span></span><br><span class="line">    <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;/summary&gt;</span></span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">string</span> FolderName &#123; <span class="keyword">get</span>; <span class="keyword">set</span>; &#125; = <span class="string">""</span>;</span><br><span class="line">    <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;summary&gt;</span></span></span><br><span class="line">    <span class="comment"><span class="doctag">///</span> 附件个数</span></span><br><span class="line">    <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;/summary&gt;</span></span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span>? AttaCount &#123; <span class="keyword">get</span>; <span class="keyword">set</span>; &#125;</span><br><span class="line"></span><br><span class="line">    [<span class="meta">NotMapped</span>]</span><br><span class="line">    <span class="keyword">public</span> List&lt;MailBoxEntity&gt; MailBoxList &#123; <span class="keyword">get</span>; <span class="keyword">set</span>; &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="邮箱发送服务器配置"><a href="#邮箱发送服务器配置" class="headerlink" title="邮箱发送服务器配置"></a>邮箱发送服务器配置</h4><p>此表用于保存邮箱的账号信息及不同邮箱服务器的SMTP端口等信息</p>
<p>当然，这些信息可以拆分成两个表存储。</p>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">MailConfigEntity</span> : <span class="title">BaseEntity</span> &#123;</span><br><span class="line">    <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;summary&gt;</span></span></span><br><span class="line">    <span class="comment"><span class="doctag">///</span> 邮箱显示名</span></span><br><span class="line">    <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;/summary&gt;</span></span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">string</span> DisplayName &#123; <span class="keyword">get</span>; <span class="keyword">set</span>; &#125; = <span class="string">""</span>;</span><br><span class="line">    <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;summary&gt;</span></span></span><br><span class="line">    <span class="comment"><span class="doctag">///</span> 发件SMTP服务器地址</span></span><br><span class="line">    <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;/summary&gt;</span></span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">string</span> SmtpHost &#123; <span class="keyword">get</span>; <span class="keyword">set</span>; &#125; = <span class="string">""</span>;</span><br><span class="line">    <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;summary&gt;</span></span></span><br><span class="line">    <span class="comment"><span class="doctag">///</span> 收件Imtp服务器地址</span></span><br><span class="line">    <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;/summary&gt;</span></span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">string</span> ImapHost &#123; <span class="keyword">get</span>; <span class="keyword">set</span>; &#125; = <span class="string">""</span>;</span><br><span class="line">    <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;summary&gt;</span></span></span><br><span class="line">    <span class="comment"><span class="doctag">///</span> 发件SMTP服务器端口</span></span><br><span class="line">    <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;/summary&gt;</span></span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span>? SmtpPort &#123; <span class="keyword">get</span>; <span class="keyword">set</span>; &#125;</span><br><span class="line">    <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;summary&gt;</span></span></span><br><span class="line">    <span class="comment"><span class="doctag">///</span> 收件Imtp服务器端口</span></span><br><span class="line">    <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;/summary&gt;</span></span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span>? ImapPort &#123; <span class="keyword">get</span>; <span class="keyword">set</span>; &#125;</span><br><span class="line">    <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;summary&gt;</span></span></span><br><span class="line">    <span class="comment"><span class="doctag">///</span> 是否启用SSL</span></span><br><span class="line">    <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;/summary&gt;</span></span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">bool</span> IsSsl &#123; <span class="keyword">get</span>; <span class="keyword">set</span>; &#125; = <span class="literal">true</span>;</span><br><span class="line">    <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;summary&gt;</span></span></span><br><span class="line">    <span class="comment"><span class="doctag">///</span> 邮件编码</span></span><br><span class="line">    <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;/summary&gt;</span></span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">string</span> MailEncoding &#123; <span class="keyword">get</span>; <span class="keyword">set</span>; &#125; = <span class="string">"UTF-8"</span>;</span><br><span class="line">    <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;summary&gt;</span></span></span><br><span class="line">    <span class="comment"><span class="doctag">///</span> 邮箱账号</span></span><br><span class="line">    <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;/summary&gt;</span></span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">string</span> Account &#123; <span class="keyword">get</span>; <span class="keyword">set</span>; &#125;</span><br><span class="line">    <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;summary&gt;</span></span></span><br><span class="line">    <span class="comment"><span class="doctag">///</span> 邮箱密码/授权码</span></span><br><span class="line">    <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;/summary&gt;</span></span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">string</span> Password &#123; <span class="keyword">get</span>; <span class="keyword">set</span>; &#125;</span><br><span class="line">    <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;summary&gt;</span></span></span><br><span class="line">    <span class="comment"><span class="doctag">///</span> 平台ID</span></span><br><span class="line">    <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;/summary&gt;</span></span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span> PlatId &#123; <span class="keyword">get</span>; <span class="keyword">set</span>; &#125;</span><br><span class="line">    <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;summary&gt;</span></span></span><br><span class="line">    <span class="comment"><span class="doctag">///</span> 更新到的日期</span></span><br><span class="line">    <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;/summary&gt;</span></span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">string</span> UpdateTo &#123; <span class="keyword">get</span>; <span class="keyword">set</span>; &#125;</span><br><span class="line">    <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;summary&gt;</span></span></span><br><span class="line">    <span class="comment"><span class="doctag">///</span> 总发件数量</span></span><br><span class="line">    <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;/summary&gt;</span></span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span> SentCount &#123; <span class="keyword">get</span>; <span class="keyword">set</span>; &#125; = <span class="number">0</span>;</span><br><span class="line">    <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;summary&gt;</span></span></span><br><span class="line">    <span class="comment"><span class="doctag">///</span> 员工自定义的文件夹列表</span></span><br><span class="line">    <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;/summary&gt;</span></span></span><br><span class="line">    [<span class="meta">NotMapped</span>]</span><br><span class="line">    <span class="keyword">public</span> List&lt;MailFolderEntity&gt; MailFolders &#123; <span class="keyword">get</span>; <span class="keyword">set</span>; &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="邮件发送结果信息"><a href="#邮件发送结果信息" class="headerlink" title="邮件发送结果信息"></a>邮件发送结果信息</h4><p>用于保存每一封邮件的发送状态，后续也可以关联其它业务表，与自动发送邮件任务配合，记录更多相关信息</p>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">SendResultEntity</span> : <span class="title">BaseEntity</span> &#123;</span><br><span class="line">    <span class="comment">// [MaxLength (50)]</span></span><br><span class="line">    <span class="comment">// public string OrderId &#123; get; set; &#125;</span></span><br><span class="line">    <span class="comment">// [MaxLength (50)]</span></span><br><span class="line">    <span class="comment">// public string ReviewId &#123; get; set; &#125;</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span> MailId &#123; <span class="keyword">get</span>; <span class="keyword">set</span>; &#125;</span><br><span class="line">    <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;summary&gt;</span></span></span><br><span class="line">    <span class="comment"><span class="doctag">///</span> 结果信息</span></span><br><span class="line">    <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;/summary&gt;</span></span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">string</span> ResultInformation &#123; <span class="keyword">get</span>; <span class="keyword">set</span>; &#125; = <span class="string">"发送成功！"</span>;</span><br><span class="line">    <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;summary&gt;</span></span></span><br><span class="line">    <span class="comment"><span class="doctag">///</span> 结果状态</span></span><br><span class="line">    <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;/summary&gt;</span></span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">bool</span> ResultStatus &#123; <span class="keyword">get</span>; <span class="keyword">set</span>; &#125; = <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="邮件操作服务"><a href="#邮件操作服务" class="headerlink" title="邮件操作服务"></a>邮件操作服务</h3><h4 id="配置基础信息"><a href="#配置基础信息" class="headerlink" title="配置基础信息"></a>配置基础信息</h4><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;summary&gt;</span></span></span><br><span class="line"><span class="comment"><span class="doctag">///</span> 账户认证</span></span><br><span class="line"><span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;/summary&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">Authenticate</span> (<span class="params">MailConfigEntity mailConfigEntity, SmtpClient client, SendResultEntity sendResultEntity</span>)</span> &#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        client.Authenticate (mailConfigEntity.Account, mailConfigEntity.Password);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (AuthenticationException ex) &#123;</span><br><span class="line">        sendResultEntity.ResultInformation = <span class="string">$"无效的用户名或密码:<span class="subst">&#123;<span class="number">0</span>&#125;</span>"</span> + ex.Message;</span><br><span class="line">        sendResultEntity.ResultStatus = <span class="literal">false</span>;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (SmtpCommandException ex) &#123;</span><br><span class="line">        sendResultEntity.ResultInformation = <span class="string">$"尝试验证错误:<span class="subst">&#123;<span class="number">0</span>&#125;</span>"</span> + ex.Message;</span><br><span class="line">        sendResultEntity.ResultStatus = <span class="literal">false</span>;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (SmtpProtocolException ex) &#123;</span><br><span class="line">        sendResultEntity.ResultInformation = <span class="string">$"尝试验证时的协议错误:<span class="subst">&#123;<span class="number">0</span>&#125;</span>"</span> + ex.Message;</span><br><span class="line">        sendResultEntity.ResultStatus = <span class="literal">false</span>;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Exception ex) &#123;</span><br><span class="line">        sendResultEntity.ResultInformation = <span class="string">$"账户认证错误:<span class="subst">&#123;<span class="number">0</span>&#125;</span>"</span> + ex.Message;</span><br><span class="line">        sendResultEntity.ResultStatus = <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;summary&gt;</span></span></span><br><span class="line"><span class="comment"><span class="doctag">///</span> 获取SMTP基础信息</span></span><br><span class="line"><span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;/summary&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">private</span> MailServerInformationEntity <span class="title">SmtpClientBaseMessage</span> (<span class="params">SmtpClient client</span>)</span> &#123;</span><br><span class="line">    <span class="keyword">var</span> mailServerInformation = <span class="keyword">new</span> MailServerInformationEntity &#123;</span><br><span class="line">        Authentication = client.Capabilities.HasFlag (SmtpCapabilities.Authentication),</span><br><span class="line">        BinaryMime = client.Capabilities.HasFlag (SmtpCapabilities.BinaryMime),</span><br><span class="line">        Dsn = client.Capabilities.HasFlag (SmtpCapabilities.Dsn),</span><br><span class="line">        EightBitMime = client.Capabilities.HasFlag (SmtpCapabilities.EightBitMime),</span><br><span class="line">        Size = client.MaxSize</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="keyword">return</span> mailServerInformation;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;summary&gt;</span></span></span><br><span class="line"><span class="comment"><span class="doctag">///</span> 连接服务器</span></span><br><span class="line"><span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;/summary&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">Connection</span> (<span class="params">MailConfigEntity sendServerConfiguration, SmtpClient client, SendResultEntity sendResultEntity</span>)</span> &#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        client.Connect (sendServerConfiguration.SmtpHost, sendServerConfiguration.SmtpPort.Value);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (SmtpCommandException ex) &#123;</span><br><span class="line">        sendResultEntity.ResultInformation = <span class="string">$"尝试连接时出错:<span class="subst">&#123;<span class="number">0</span>&#125;</span>"</span> + ex.Message;</span><br><span class="line">        sendResultEntity.ResultStatus = <span class="literal">false</span>;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (SmtpProtocolException ex) &#123;</span><br><span class="line">        sendResultEntity.ResultInformation = <span class="string">$"尝试连接时的协议错误:<span class="subst">&#123;<span class="number">0</span>&#125;</span>"</span> + ex.Message;</span><br><span class="line">        sendResultEntity.ResultStatus = <span class="literal">false</span>;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Exception ex) &#123;</span><br><span class="line">        sendResultEntity.ResultInformation = <span class="string">$"服务器连接错误:<span class="subst">&#123;<span class="number">0</span>&#125;</span>"</span> + ex.Message;</span><br><span class="line">        sendResultEntity.ResultStatus = <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"> <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;summary&gt;</span></span></span><br><span class="line"> <span class="comment"><span class="doctag">///</span> 设置发件人信息</span></span><br><span class="line"> <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;/summary&gt;</span></span></span><br><span class="line"> <span class="function"><span class="keyword">private</span> SmtpClient <span class="title">SmtpClientInit</span> (<span class="params"><span class="keyword">int</span> accountId</span>)</span> &#123;</span><br><span class="line">     <span class="keyword">var</span> m = _mailConfigService.GetAsNoTracking ();</span><br><span class="line">     MailConfigEntity mailConfig = m.FirstOrDefault (a =&gt; a.FID == accountId);</span><br><span class="line">     SmtpClient client = <span class="keyword">new</span> SmtpClient () &#123;</span><br><span class="line">         ServerCertificateValidationCallback = (s, c, h, e) =&gt; <span class="literal">true</span></span><br><span class="line">     &#125;;</span><br><span class="line">     <span class="keyword">var</span> sendResultEntity = <span class="keyword">new</span> SendResultEntity ();</span><br><span class="line">     Connection (mailConfig, client, sendResultEntity);</span><br><span class="line">     <span class="keyword">if</span> (sendResultEntity.ResultStatus == <span class="literal">false</span>)</span><br><span class="line">         <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">     SmtpClientBaseMessage (client);</span><br><span class="line">     Authenticate (mailConfig, client, sendResultEntity);</span><br><span class="line">     <span class="keyword">return</span> sendResultEntity.ResultStatus == <span class="literal">false</span> ? <span class="literal">null</span> : client;</span><br><span class="line"> &#125;</span><br><span class="line"> <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;summary&gt;</span></span></span><br><span class="line"> <span class="comment"><span class="doctag">///</span> 设置收件人信息</span></span><br><span class="line"> <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;/summary&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> ImapClient <span class="title">ImapClientInit</span> (<span class="params"><span class="keyword">int</span> AccountId</span>)</span> &#123;</span><br><span class="line">    MailConfigEntity mailConfig = _mailConfigService.GetAsNoTracking ().FirstOrDefault (a =&gt; a.FID == AccountId);</span><br><span class="line">    ImapClient client = <span class="keyword">new</span> ImapClient ();</span><br><span class="line">    client.Connect (mailConfig.ImapHost, mailConfig.ImapPort.Value,</span><br><span class="line">        SecureSocketOptions.SslOnConnect);</span><br><span class="line">    client.Authenticate (mailConfig.Account, mailConfig.Password);</span><br><span class="line">    <span class="meta">#<span class="meta-keyword">region</span> 网易邮箱需要此语句，用于验证客户端身份</span></span><br><span class="line">    <span class="keyword">if</span> (mailConfig.ImapHost == <span class="string">"imap.126.com"</span> || mailConfig.ImapHost == <span class="string">"imap.163.com"</span>) &#123;</span><br><span class="line">        <span class="keyword">var</span> clientImplementation = <span class="keyword">new</span> ImapImplementation &#123;</span><br><span class="line">        Name = <span class="string">"MeSince"</span>,</span><br><span class="line">        Version = <span class="string">"2.0"</span></span><br><span class="line">        &#125;;</span><br><span class="line">        client.Identify (clientImplementation);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">#<span class="meta-keyword">endregion</span></span></span><br><span class="line">    <span class="keyword">return</span> client;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="发送邮件"><a href="#发送邮件" class="headerlink" title="发送邮件"></a>发送邮件</h4><p><em>Mailkit使用时会遇到“附件文件名不能为中文”和“附件文件名长度不能超过41字符”的Bug，这里我顺便参照网上的解决了</em></p>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;summary&gt;</span></span></span><br><span class="line"><span class="comment"><span class="doctag">///</span> 组装邮件文本/附件邮件信息</span></span><br><span class="line"><span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;/summary&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> MimeMessage <span class="title">AssemblyMailMessage</span> (<span class="params">MailBoxEntity mailBoxEntity</span>)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (mailBoxEntity == <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> ArgumentNullException (<span class="keyword">nameof</span> (mailBoxEntity));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">var</span> message = <span class="keyword">new</span> MimeMessage ();</span><br><span class="line">    <span class="comment">//设置邮件基本信息</span></span><br><span class="line">    SetMailBaseMessage (message, mailBoxEntity);</span><br><span class="line">    <span class="keyword">var</span> multipart = <span class="keyword">new</span> Multipart (<span class="string">"mixed"</span>);</span><br><span class="line">    <span class="comment">//插入文本消息</span></span><br><span class="line">    <span class="keyword">if</span> (mailBoxEntity.MailHtmlBody.IsNotNullAndWhiteSpace ()) &#123;</span><br><span class="line">        multipart.Add (<span class="keyword">new</span> MultipartAlternative &#123;</span><br><span class="line">            AssemblyMailTextMessage (mailBoxEntity.MailHtmlBody, mailBoxEntity.MailBodyType)</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//插入附件信息</span></span><br><span class="line">    <span class="keyword">if</span> (mailBoxEntity.MailFilePath.IsNotNullAndWhiteSpace ()) &#123;</span><br><span class="line">        List&lt;FileStream&gt; list = <span class="keyword">new</span> List&lt;FileStream&gt; ();</span><br><span class="line">        <span class="keyword">foreach</span> (<span class="keyword">var</span> path <span class="keyword">in</span> mailBoxEntity.MailFilePath.Split (<span class="string">'|'</span>)) &#123;</span><br><span class="line">            <span class="keyword">if</span> (!File.Exists (path))</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> FileNotFoundException (<span class="string">"文件未找到"</span>, path);</span><br><span class="line">            <span class="keyword">string</span>[] contentTypeArr = MimeTypes.GetMimeType (path).Split (<span class="string">'/'</span>);</span><br><span class="line">            FileStream file = File.Open (path, FileMode.Open);</span><br><span class="line">            list.Add (file);</span><br><span class="line">            ContentType contentType = <span class="keyword">new</span> ContentType (contentTypeArr[<span class="number">0</span>], contentTypeArr[<span class="number">1</span>]);</span><br><span class="line">            MimePart mimePart = <span class="keyword">new</span> MimePart (contentType) &#123;</span><br><span class="line">                Content = <span class="keyword">new</span> MimeContent (file),</span><br><span class="line">                ContentDisposition = <span class="keyword">new</span> ContentDisposition (ContentDisposition.Attachment),</span><br><span class="line">                ContentTransferEncoding = ContentEncoding.Base64,</span><br><span class="line">            &#125;;</span><br><span class="line">            <span class="comment">//解决文件名不能为中文</span></span><br><span class="line">            mimePart.ContentType.Parameters.Add (<span class="string">"GB18030"</span>, <span class="string">"name"</span>, Path.GetFileName (path));</span><br><span class="line">            mimePart.ContentDisposition.Parameters.Add (<span class="string">"GB18030"</span>, <span class="string">"filename"</span>, Path.GetFileName (path));</span><br><span class="line">            <span class="comment">//解决文件名长度限制</span></span><br><span class="line">            <span class="keyword">foreach</span> (<span class="keyword">var</span> param <span class="keyword">in</span> mimePart.ContentDisposition.Parameters)</span><br><span class="line">                param.EncodingMethod = ParameterEncodingMethod.Rfc2047;</span><br><span class="line">            <span class="keyword">foreach</span> (<span class="keyword">var</span> param <span class="keyword">in</span> mimePart.ContentType.Parameters)</span><br><span class="line">                param.EncodingMethod = ParameterEncodingMethod.Rfc2047;</span><br><span class="line">            multipart.Add (mimePart);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//组合邮件内容</span></span><br><span class="line">    message.Body = multipart;</span><br><span class="line">    <span class="keyword">return</span> message;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;summary&gt;</span></span></span><br><span class="line"><span class="comment"><span class="doctag">///</span> 设置邮件基础信息</span></span><br><span class="line"><span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;/summary&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> MimeMessage <span class="title">SetMailBaseMessage</span> (<span class="params">MimeMessage minMessag, MailBoxEntity mailBoxEntity</span>)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (minMessag == <span class="literal">null</span>)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> ArgumentNullException ();</span><br><span class="line">    <span class="keyword">if</span> (mailBoxEntity == <span class="literal">null</span>)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> ArgumentNullException ();</span><br><span class="line">    <span class="comment">//插入发件人</span></span><br><span class="line">    minMessag.From.Add (<span class="keyword">new</span> MailboxAddress (mailBoxEntity.Sender, mailBoxEntity.SenderAddress));</span><br><span class="line"></span><br><span class="line">    <span class="comment">//插入收件人</span></span><br><span class="line">    <span class="keyword">string</span>[] _recipients = mailBoxEntity.Recipients.Split (<span class="string">"|"</span>);</span><br><span class="line">    <span class="keyword">foreach</span> (<span class="keyword">var</span> recipients <span class="keyword">in</span> _recipients) &#123;</span><br><span class="line">        minMessag.To.Add (<span class="keyword">new</span> MailboxAddress (recipients.Trim ()));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (mailBoxEntity.Cc.IsNotNullAndWhiteSpace ()) &#123;</span><br><span class="line">        <span class="comment">//插入抄送人</span></span><br><span class="line">        <span class="keyword">string</span>[] _cc = mailBoxEntity.Cc.Split (<span class="string">"|"</span>);</span><br><span class="line">        <span class="keyword">foreach</span> (<span class="keyword">var</span> cc <span class="keyword">in</span> _cc)</span><br><span class="line">            minMessag.Cc.Add (<span class="keyword">new</span> MailboxAddress (cc));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (mailBoxEntity.Bcc.IsNotNullAndWhiteSpace ()) &#123;</span><br><span class="line">        <span class="comment">//插入密送人</span></span><br><span class="line">        <span class="keyword">string</span>[] _bcc = mailBoxEntity.Bcc.Split (<span class="string">"|"</span>);</span><br><span class="line">        <span class="keyword">foreach</span> (<span class="keyword">var</span> bcc <span class="keyword">in</span> _bcc)</span><br><span class="line">            minMessag.Bcc.Add (<span class="keyword">new</span> MailboxAddress (bcc));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//插入主题</span></span><br><span class="line">    minMessag.Subject = mailBoxEntity.Subject;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> minMessag;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;summary&gt;</span></span></span><br><span class="line"><span class="comment"><span class="doctag">///</span> 组装邮件文本信息</span></span><br><span class="line"><span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;/summary&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> TextPart <span class="title">AssemblyMailTextMessage</span> (<span class="params"><span class="keyword">string</span> mailBody, <span class="keyword">string</span> textPartType</span>)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">string</span>.IsNullOrEmpty (mailBody))</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> ArgumentNullException ();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">string</span>.IsNullOrEmpty (textPartType))</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> ArgumentNullException ();</span><br><span class="line">    <span class="keyword">var</span> textBody = <span class="keyword">new</span> TextPart (textPartType) &#123;</span><br><span class="line">        Text = mailBody</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="keyword">return</span> textBody;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;summary&gt;</span></span></span><br><span class="line"><span class="comment"><span class="doctag">///</span> 发送邮件</span></span><br><span class="line"><span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;/summary&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">Send</span> (<span class="params">MailBoxEntity mailBoxEntity, SmtpClient client, SendResultEntity sendResultEntity, <span class="keyword">string</span> replyto, <span class="keyword">int</span> accid</span>)</span> &#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        MimeMessage mimeMessage = _mailMessageService.AssemblyMailMessage (mailBoxEntity);</span><br><span class="line">        <span class="keyword">if</span> (replyto.IsNotNullAndWhiteSpace ()) &#123;</span><br><span class="line">            <span class="keyword">uint</span>.TryParse (replyto.Trim (<span class="string">'|'</span>), <span class="keyword">out</span> <span class="keyword">uint</span> mailuint);</span><br><span class="line">            SetReplyTo (mailuint, mimeMessage, accid); <span class="comment">//设置回复</span></span><br><span class="line">        &#125;</span><br><span class="line">        client.Send (mimeMessage);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (mimeMessage.References != <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">foreach</span> (<span class="keyword">var</span> item <span class="keyword">in</span> mimeMessage.References)</span><br><span class="line">                mailBoxEntity.References = mailBoxEntity.References + <span class="string">"|"</span> + item;</span><br><span class="line">        &#125;</span><br><span class="line">        mailBoxEntity.References = mailBoxEntity.References?.Trim (<span class="string">'|'</span>);</span><br><span class="line">        mailBoxEntity.MessageId = mimeMessage.MessageId;</span><br><span class="line"></span><br><span class="line">        sendResultEntity.MailId = mailBoxEntity.MailType == (<span class="keyword">int</span>) MailType.Auto </span><br><span class="line">        ? _mailBoxService.Add (mailBoxEntity, <span class="literal">true</span>, <span class="literal">true</span>) : _mailBoxService.Add (mailBoxEntity, <span class="literal">true</span>);</span><br><span class="line"></span><br><span class="line">    &#125; <span class="keyword">catch</span> (SmtpCommandException ex) &#123;</span><br><span class="line">        <span class="keyword">switch</span> (ex.ErrorCode) &#123;</span><br><span class="line">            <span class="keyword">case</span> SmtpErrorCode.RecipientNotAccepted:</span><br><span class="line">                sendResultEntity.ResultInformation = <span class="string">$"收件人未被接受:<span class="subst">&#123;ex.Message&#125;</span>"</span>;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> SmtpErrorCode.SenderNotAccepted:</span><br><span class="line">                sendResultEntity.ResultInformation = <span class="string">$"发件人未被接受:<span class="subst">&#123;ex.Message&#125;</span>"</span>;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> SmtpErrorCode.MessageNotAccepted:</span><br><span class="line">                sendResultEntity.ResultInformation = <span class="string">$"消息未被接受:<span class="subst">&#123;ex.Message&#125;</span>"</span>;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        sendResultEntity.ResultStatus = <span class="literal">false</span>;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (SmtpProtocolException ex) &#123;</span><br><span class="line">        sendResultEntity.ResultInformation = <span class="string">$"发送消息时的协议错误:<span class="subst">&#123;ex.Message&#125;</span>"</span>;</span><br><span class="line">        sendResultEntity.ResultStatus = <span class="literal">false</span>;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Exception ex) &#123;</span><br><span class="line">        sendResultEntity.ResultInformation = <span class="string">$"邮件发送失败:<span class="subst">&#123;ex.Message&#125;</span>"</span>;</span><br><span class="line">        sendResultEntity.ResultStatus = <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="收取邮件"><a href="#收取邮件" class="headerlink" title="收取邮件"></a>收取邮件</h4><p>这部分比较繁琐，先贴代码，然后再解释</p>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;summary&gt;</span></span></span><br><span class="line"><span class="comment"><span class="doctag">///</span> 接收所有文件夹的邮件</span></span><br><span class="line"><span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;/summary&gt;</span> </span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">bool</span> <span class="title">GetFolders</span> (<span class="params"><span class="keyword">string</span> Account</span>)</span> &#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">bool</span> result = <span class="literal">false</span>;</span><br><span class="line">        MailConfigEntity mailConfig = _mailConfigService.Get ().FirstOrDefault (a =&gt; a.Account == Account);</span><br><span class="line"></span><br><span class="line">        List&lt;DateTime&gt; dateTimes = <span class="keyword">new</span> List&lt;DateTime&gt; &#123;</span><br><span class="line">            Convert.ToDateTime (mailConfig.UpdateTo)</span><br><span class="line">        &#125;;</span><br><span class="line">        <span class="comment">// 用户所拥有的文件夹</span></span><br><span class="line">        <span class="keyword">var</span> mailFolderUserEntitys = _mailFolderUserService.GetAsNoTracking ().</span><br><span class="line">        Where (a =&gt; a.AccountUserID == _applicationContext.CurrentUser.FID &amp;&amp; a.DataStatus == (<span class="keyword">int</span>) DataStatus.Active)</span><br><span class="line">            .Select (a =&gt; a.MailFolderId).ToArray ();</span><br><span class="line">        <span class="comment">// 文件夹详细信息</span></span><br><span class="line">        <span class="keyword">var</span> mailFolders = _mailFolderService.GetAsNoTracking ().Where (a =&gt; a.MailAccountId == mailConfig.FID &amp;&amp;</span><br><span class="line">            a.DataStatus == (<span class="keyword">int</span>) DataStatus.Active &amp;&amp; a.FolderType == <span class="number">1</span> &amp;&amp; mailFolderUserEntitys.Contains (a.FID));</span><br><span class="line"></span><br><span class="line">        <span class="keyword">var</span> mailFoldersArr = mailFolders.Where (a =&gt; mailFolders.Any (r =&gt; r.ParentFolderId == a.FID) == <span class="literal">false</span>).Select (a =&gt; a.FID).ToArray ();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 文件夹规则表</span></span><br><span class="line">        <span class="keyword">var</span> mailFolderRuleEntities = _mailFolderRuleService.GetAsNoTracking ().Where (a =&gt; mailFoldersArr.Contains (a.FolderId) &amp;&amp;</span><br><span class="line">            a.DataStatus == (<span class="keyword">int</span>) DataStatus.Active &amp;&amp; a.RuleContent.IsNotNullAndWhiteSpace ()).ToList ();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">using</span> (<span class="keyword">var</span> client = ImapClientInit (mailConfig.FID)) &#123;</span><br><span class="line">            List&lt;IMailFolder&gt; mailFolderList = client.GetFolders (client.PersonalNamespaces[<span class="number">0</span>]).ToList ();</span><br><span class="line">            <span class="keyword">foreach</span> (<span class="keyword">var</span> item <span class="keyword">in</span> mailFolderList) &#123;</span><br><span class="line">                item.Open (FolderAccess.ReadOnly);</span><br><span class="line">                <span class="comment">//todo 因未知原因,拉取Junk文件夹邮件拉取时会报错，先跳过</span></span><br><span class="line">                <span class="keyword">if</span> (item.Count &lt; <span class="number">1</span> || item.Name.ToLower () == <span class="string">"junk"</span>) <span class="keyword">continue</span>;</span><br><span class="line">                <span class="keyword">var</span> m = FillEntity (<span class="literal">null</span>, <span class="literal">null</span>, item, client, <span class="literal">true</span>, mailConfig.FID);</span><br><span class="line">                <span class="keyword">if</span> (m.MailBoxList.Count &lt; <span class="number">1</span>) <span class="keyword">continue</span>;</span><br><span class="line">                <span class="keyword">if</span> (item.Name.ToLower () == <span class="string">"inbox"</span>) &#123;</span><br><span class="line">                    result = <span class="literal">true</span>;</span><br><span class="line">                    <span class="comment">// 邮件归档</span></span><br><span class="line">                    <span class="keyword">if</span> (mailFolderRuleEntities.Any ())</span><br><span class="line">                        MailArchive (m.MailBoxList, mailFolderRuleEntities);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">//取出邮件后对比 获得当前文件夹最后一封邮件的时间</span></span><br><span class="line">                <span class="keyword">string</span> maxdate = m.MailBoxList.Max (a =&gt; a.Date);</span><br><span class="line">                DateTime.TryParse (mailConfig.UpdateTo, <span class="keyword">out</span> <span class="keyword">var</span> updateTo);</span><br><span class="line">                DateTime.TryParse (maxdate, <span class="keyword">out</span> <span class="keyword">var</span> date);</span><br><span class="line">                <span class="keyword">if</span> (date &gt; updateTo) dateTimes.Add (Convert.ToDateTime (maxdate));</span><br><span class="line">                <span class="comment">//保存所有邮件 </span></span><br><span class="line">                _mailBoxService.AddRange (m.MailBoxList);</span><br><span class="line">            &#125;</span><br><span class="line">            client.Disconnect (<span class="literal">true</span>);</span><br><span class="line">            <span class="comment">// 最后更新时间取所有文件夹最大时间 避免覆盖或取值错误</span></span><br><span class="line">            mailConfig.UpdateTo = dateTimes.Max ().ToString (<span class="string">"yyyy-MM-dd HH:mm:ss"</span>);</span><br><span class="line">            <span class="comment">//todo 此处排除字段修改无效</span></span><br><span class="line">            _mailConfigService.Update (mailConfig, <span class="literal">false</span>, <span class="string">"SentCount"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">        <span class="keyword">throw</span> e;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;summary&gt;</span></span></span><br><span class="line"><span class="comment"><span class="doctag">///</span> 填充实体   </span></span><br><span class="line"><span class="comment"><span class="doctag">///</span> 返回新邮件数量</span></span><br><span class="line"><span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;/summary&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">private</span> MailBoxEntity <span class="title">FillEntity</span> (<span class="params">IMessageSummary emhead = <span class="literal">null</span>, MimeMessage embody = <span class="literal">null</span>, IMailFolder folder = <span class="literal">null</span>, ImapClient client = <span class="literal">null</span>, <span class="keyword">bool</span> Loop = <span class="literal">false</span>, <span class="keyword">int</span> AccountId = <span class="number">0</span></span>)</span> &#123;</span><br><span class="line">         MailBoxEntity mailbox = <span class="keyword">new</span> MailBoxEntity ();</span><br><span class="line">         <span class="keyword">if</span> (emhead != <span class="literal">null</span>) &#123;</span><br><span class="line">             <span class="keyword">if</span> (emhead.Envelope.From.Count &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                 mailbox.Sender = emhead.Envelope.From.Mailboxes.ElementAt (<span class="number">0</span>).Name;</span><br><span class="line">                 mailbox.SenderAddress = emhead.Envelope.From.Mailboxes.ElementAt (<span class="number">0</span>).Address;</span><br><span class="line">             &#125;</span><br><span class="line">             <span class="comment">//记录邮件唯一标识 后续获取邮件全文后可直接修改</span></span><br><span class="line">             mailbox.MessageId = emhead.Envelope.MessageId;</span><br><span class="line">             <span class="comment">//记录邮件唯一查询标识 后续根据此字段及文件夹联合查询邮件全文</span></span><br><span class="line">             mailbox.UniqueId = emhead.UniqueId.Id;</span><br><span class="line">             <span class="comment">//直接取本地时间 忽略时间差</span></span><br><span class="line">             mailbox.Date = emhead.Date.LocalDateTime.ToString (<span class="string">"yyyy-MM-dd HH:mm:ss"</span>);</span><br><span class="line">             <span class="comment">//邮件时间=本地时间+时区差</span></span><br><span class="line">             <span class="comment">//mailbox.Date = emhead.Date.LocalDateTime.</span></span><br><span class="line">             <span class="comment">//    AddHours(emhead.Date.Offset.TotalHours).ToString("yyyy-MM-dd HH:mm:ss");               </span></span><br><span class="line">             mailbox.Subject = emhead.Envelope.Subject;</span><br><span class="line">             <span class="comment">// 有文件夹的则记录邮件头所属文件夹</span></span><br><span class="line">             <span class="keyword">if</span> (folder != <span class="literal">null</span>) &#123;</span><br><span class="line">                 <span class="keyword">if</span> (folder.Attributes.ToString ().Contains (<span class="string">"Inbox"</span>))</span><br><span class="line">                     mailbox.FolderType = <span class="string">"Inbox"</span>;</span><br><span class="line">                 <span class="keyword">else</span> <span class="keyword">if</span> (folder.Attributes.ToString ().Contains (<span class="string">"Sent"</span>))</span><br><span class="line">                     mailbox.FolderType = <span class="string">"Sent"</span>;</span><br><span class="line">                 <span class="keyword">else</span> <span class="keyword">if</span> (folder.Attributes.ToString ().Contains (<span class="string">"Trash"</span>))</span><br><span class="line">                     mailbox.FolderType = <span class="string">"Trash"</span>;</span><br><span class="line">                 <span class="keyword">else</span> <span class="keyword">if</span> (folder.Attributes.ToString ().Contains (<span class="string">"Drafts"</span>))</span><br><span class="line">                     mailbox.FolderType = <span class="string">"Drafts"</span>;</span><br><span class="line">                 <span class="keyword">else</span></span><br><span class="line">                     mailbox.FolderType = <span class="string">"Inbox"</span>;</span><br><span class="line">                 mailbox.FolderName = folder.FullName;</span><br><span class="line">             &#125;</span><br><span class="line">             <span class="comment">// 循环记录收件人</span></span><br><span class="line">             <span class="keyword">foreach</span> (<span class="keyword">var</span> _Recipients <span class="keyword">in</span> emhead.Envelope.To.Mailboxes)</span><br><span class="line">                 mailbox.Recipients = mailbox.Recipients + <span class="string">"|"</span> + _Recipients.Address.Trim ();</span><br><span class="line">             mailbox.Recipients = mailbox.Recipients?.Trim (<span class="string">'|'</span>);</span><br><span class="line">             <span class="comment">//标记为收到的邮件</span></span><br><span class="line">             mailbox.MailType = (<span class="keyword">int</span>) MailType.In;</span><br><span class="line">             <span class="comment">// 邮件状态,已读未读等等</span></span><br><span class="line">             <span class="keyword">if</span> (emhead.Flags.HasValue &amp;&amp; mailbox.FolderType == <span class="string">"Inbox"</span>) &#123;</span><br><span class="line">                 mailbox.IsRead = emhead.Flags.Value.HasFlag (MessageFlags.Seen);</span><br><span class="line">                 mailbox.IsAnswered = emhead.Flags.Value.HasFlag (MessageFlags.Answered);</span><br><span class="line">             &#125;</span><br><span class="line">             <span class="comment">// 附件个数</span></span><br><span class="line">             mailbox.AttaCount = emhead.Attachments.Count ();</span><br><span class="line">         &#125;</span><br><span class="line">         <span class="keyword">if</span> (embody != <span class="literal">null</span>) &#123;</span><br><span class="line">             mailbox.OwnerMailAccount = AccountId;</span><br><span class="line">             <span class="comment">// 正文</span></span><br><span class="line">             mailbox.MailTextBody = embody.TextBody;</span><br><span class="line">             mailbox.MailHtmlBody = embody.HtmlBody;</span><br><span class="line">             <span class="keyword">foreach</span> (<span class="keyword">var</span> _Cc <span class="keyword">in</span> embody.Cc) <span class="comment">//抄送</span></span><br><span class="line">                 mailbox.Cc = embody.Cc + <span class="string">"|"</span> + ((MailboxAddress) _Cc).Address.Trim ();</span><br><span class="line">             mailbox.Cc = mailbox.Cc?.Trim (<span class="string">'|'</span>);</span><br><span class="line">             <span class="keyword">foreach</span> (<span class="keyword">var</span> _Bcc <span class="keyword">in</span> embody.Bcc) <span class="comment">//密送</span></span><br><span class="line">                 mailbox.Bcc = embody.Bcc + <span class="string">"|"</span> + ((MailboxAddress) _Bcc).Address.Trim ();</span><br><span class="line">             mailbox.Bcc = mailbox.Bcc?.Trim (<span class="string">'|'</span>);</span><br><span class="line">             <span class="keyword">foreach</span> (<span class="keyword">var</span> _References <span class="keyword">in</span> embody.References) <span class="comment">//引用</span></span><br><span class="line">                 mailbox.References = embody.References + <span class="string">"|"</span> + _References;</span><br><span class="line">             mailbox.References = mailbox.References?.Trim (<span class="string">'|'</span>);</span><br><span class="line">             <span class="keyword">if</span> (embody.Attachments.Count () &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                 <span class="comment">// 收件箱箱附件保存路径</span></span><br><span class="line">                 <span class="keyword">string</span> _guid = !<span class="keyword">string</span>.IsNullOrEmpty (embody.MessageId) ? embody.MessageId : Guid.NewGuid ().ToString ();</span><br><span class="line">                 <span class="keyword">string</span> _rootPath = Directory.GetDirectoryRoot (Directory.GetCurrentDirectory ()) + <span class="string">@"RecMailAttachment\"</span> + <span class="string">$" <span class="subst">&#123; _guid &#125;</span></span></span><br><span class="line"><span class="string">                 "</span>;</span><br><span class="line">            <span class="keyword">if</span> (!Directory.Exists(_rootPath))</span><br><span class="line">                Directory.CreateDirectory(_rootPath);</span><br><span class="line">            FileInfo fileInfo;</span><br><span class="line">            <span class="comment">//附件路径集合</span></span><br><span class="line">            List&lt;<span class="keyword">string</span>&gt; _attachPaths = <span class="keyword">new</span> List&lt;<span class="keyword">string</span>&gt;();</span><br><span class="line">            <span class="comment">// 这里要转成mimepart类型</span></span><br><span class="line">            <span class="keyword">foreach</span> (MimePart attachment <span class="keyword">in</span> embody.Attachments)</span><br><span class="line">            &#123;</span><br><span class="line">                fileInfo = <span class="keyword">new</span> FileInfo(Path.Combine(_rootPath, attachment.FileName));</span><br><span class="line">                _attachPaths.Add(fileInfo.ToString());</span><br><span class="line">                <span class="keyword">if</span> (File.Exists(fileInfo.ToString())) <span class="keyword">continue</span>;</span><br><span class="line">                <span class="keyword">using</span> (FileStream fs = <span class="keyword">new</span> FileStream(fileInfo.ToString(), FileMode.Create))</span><br><span class="line">                &#123;</span><br><span class="line">                    attachment.Content.DecodeTo(fs);</span><br><span class="line">                    fs.Flush();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            mailbox.MailFilePath = _attachPaths.Aggregate((ttl, next) =&gt; <span class="keyword">string</span>.Format(<span class="string">$" <span class="subst">&#123; ttl &#125;</span> | <span class="subst">&#123; next &#125;</span>"</span>));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//不需要循环或者未指定文件夹的直接返回</span></span><br><span class="line">    <span class="keyword">if</span> (folder == <span class="literal">null</span> || !Loop)</span><br><span class="line">        <span class="keyword">return</span> mailbox;</span><br><span class="line">    <span class="comment">//需要循环的则循环整个文件夹取值</span></span><br><span class="line">    MailConfigEntity mailConfig = _mailConfigService.Get ().FirstOrDefault (a =&gt; a.FID == AccountId);</span><br><span class="line">    <span class="keyword">var</span> mails = _mailBoxService.GetAsNoTracking ().Where (a =&gt; a.OwnerMailAccount == mailConfig.FID &amp;&amp; a.MailType == <span class="number">1</span>).Select (a =&gt; a.UniqueId);</span><br><span class="line">    mailbox.MailBoxList = <span class="keyword">new</span> List&lt;MailBoxEntity&gt; ();</span><br><span class="line">    IList&lt;UniqueId&gt; uids;</span><br><span class="line">    <span class="comment">//如果之前更新过 则仅同步上次同步之后的邮件</span></span><br><span class="line">    DateTime Updateto = DateTime.MinValue;</span><br><span class="line">    <span class="keyword">if</span> (mailConfig.UpdateTo.IsNotNullAndWhiteSpace ())</span><br><span class="line">    &#123;</span><br><span class="line">        DateTime.TryParse (mailConfig.UpdateTo, <span class="keyword">out</span> Updateto);</span><br><span class="line">        uids = client.GetFolder (folder.FullName).Search (SearchQuery.DeliveredAfter (Updateto));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span><span class="comment">//若是第一次更新 则取出所有邮件</span></span><br><span class="line">        uids = client.GetFolder (folder.FullName).Search (SearchQuery.All);</span><br><span class="line">    <span class="keyword">if</span> (uids.Count &lt; <span class="number">1</span>) <span class="keyword">return</span> mailbox;</span><br><span class="line">    <span class="keyword">int</span> pagecount;</span><br><span class="line">    <span class="keyword">int</span> sum = uids.Count &gt; <span class="number">1000</span> ? <span class="number">1000</span> : uids.Count;</span><br><span class="line">    <span class="keyword">int</span> pageSize = <span class="number">100</span>; <span class="comment">// 每页记录数</span></span><br><span class="line">    <span class="keyword">if</span> (sum % pageSize == <span class="number">0</span>)</span><br><span class="line">        pagecount =sum / pageSize;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        pagecount = sum / pageSize + <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= pagecount; i++)<span class="comment">//分页取最后一千封邮件</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">var</span> cpage = uids.SkipLast ((i - <span class="number">1</span>) * pageSize).TakeLast (pageSize).ToList ();</span><br><span class="line">        <span class="keyword">var</span> items = folder.Fetch (cpage, MessageSummaryItems.UniqueId | MessageSummaryItems.All);</span><br><span class="line">        <span class="keyword">foreach</span> (<span class="keyword">var</span> item <span class="keyword">in</span> items)</span><br><span class="line">        &#123;</span><br><span class="line">            DateTime.TryParse (item.Date.LocalDateTime.ToString (), <span class="keyword">out</span> DateTime date);</span><br><span class="line">            <span class="keyword">if</span> (date &lt; Updateto || mails.Any (a =&gt; a == item.UniqueId.Id))</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            <span class="comment">//取出正文</span></span><br><span class="line">            MimeMessage ebody = folder.GetMessage (item.UniqueId);</span><br><span class="line">            <span class="keyword">var</span> mbox = FillEntity (item, ebody, folder, <span class="literal">null</span>, <span class="literal">false</span>, AccountId);</span><br><span class="line">            mailbox.MailBoxList.Add (mbox);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> mailbox;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>原本逻辑为初次仅拉取邮件头，用户点击详情后再拉取详情。收件速度可成倍提升</p>
<p>但目前客户需求在列表预览邮件部分内容，所以暂时选择全部拉取，后续可以改为仅拉取加载出邮件头的详情</p>
<h4 id="其他操作"><a href="#其他操作" class="headerlink" title="其他操作"></a>其他操作</h4><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;summary&gt;</span></span></span><br><span class="line"><span class="comment"><span class="doctag">///</span> 设置单个邮件状态</span></span><br><span class="line"><span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;/summary&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">private</span> MimeMessage <span class="title">SetMailFlag</span> (<span class="params">MessageFlags Flage, <span class="keyword">uint</span> uniqueid, <span class="keyword">int</span> accountId, <span class="keyword">string</span> folderName = <span class="literal">null</span></span>)</span> &#123;</span><br><span class="line">    MimeMessage remail;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// 查找这个邮件,设置状态</span></span><br><span class="line">        <span class="keyword">using</span> (<span class="keyword">var</span> client = _receiveEmailService.ImapClientInit (accountId)) &#123;</span><br><span class="line">            <span class="keyword">if</span> (folderName == <span class="literal">null</span>)</span><br><span class="line">                folderName = client.Inbox.Name;</span><br><span class="line">            <span class="keyword">var</span> emailUniqueId = <span class="keyword">new</span> UniqueId (uniqueid);</span><br><span class="line">            <span class="keyword">var</span> folder = client.GetFolder (folderName);</span><br><span class="line">            folder.Open (FolderAccess.ReadWrite);</span><br><span class="line">            remail = folder.GetMessage (emailUniqueId);</span><br><span class="line">            folder.AddFlags (emailUniqueId, Flage, <span class="literal">true</span>);</span><br><span class="line">            folder.Close ();</span><br><span class="line">            client.Disconnect (<span class="literal">true</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">        <span class="keyword">throw</span> e;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> remail;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;summary&gt;</span></span></span><br><span class="line"><span class="comment"><span class="doctag">///</span> 将邮件保存到草稿箱 返回邮件的唯一标识</span></span><br><span class="line"><span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;/summary&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">SaveDrafts</span> (<span class="params">MailBoxEntity mailBox, <span class="keyword">int</span> accountId, <span class="keyword">int</span> uniqueId = <span class="number">-1</span></span>)</span> &#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        MimeMessage mimeMessage = _mailMessageService.AssemblyMailMessage (mailBox);</span><br><span class="line">        <span class="keyword">using</span> (<span class="keyword">var</span> client = _receiveEmailService.ImapClientInit (accountId)) &#123;</span><br><span class="line">            IMailFolder folder = client.GetFolder (SpecialFolder.Drafts);</span><br><span class="line">            folder.Open (FolderAccess.ReadWrite);</span><br><span class="line">            <span class="comment">// 如果保存的是已经有的草稿邮件,则删除它再保存新的草稿.(没找到保存已有草稿的办法)</span></span><br><span class="line">            <span class="keyword">if</span> (uniqueId &gt; <span class="number">-1</span>) &#123;</span><br><span class="line">                List&lt;UniqueId&gt; uidls = <span class="keyword">new</span> List&lt;UniqueId&gt; &#123;</span><br><span class="line">                    <span class="keyword">new</span> UniqueId ((<span class="keyword">uint</span>) uniqueId)</span><br><span class="line">                &#125;;</span><br><span class="line">                folder.SetFlags (uidls, MessageFlags.Seen | MessageFlags.Deleted, <span class="literal">true</span>);</span><br><span class="line">                folder.Expunge (uidls);</span><br><span class="line">            &#125;</span><br><span class="line">            UniqueId? uid = folder.Append (mimeMessage, MessageFlags.Seen | MessageFlags.Draft);</span><br><span class="line">            folder.Close ();</span><br><span class="line">            client.Disconnect (<span class="literal">true</span>);</span><br><span class="line">            <span class="keyword">return</span> uid.HasValue ? (<span class="keyword">int</span>) uid.Value.Id : <span class="number">-1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">        <span class="keyword">throw</span> e;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;summary&gt;</span></span></span><br><span class="line"><span class="comment"><span class="doctag">///</span> 设置邮件已读</span></span><br><span class="line"><span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;/summary&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">bool</span> <span class="title">SetSeen</span> (<span class="params"><span class="keyword">uint</span> uniqueid, <span class="keyword">int</span> accountId, <span class="keyword">string</span> folderName = <span class="literal">null</span></span>)</span> &#123;</span><br><span class="line">    <span class="keyword">bool</span> r = <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        SetMailFlag (MessageFlags.Seen, uniqueid, accountId, folderName);</span><br><span class="line">        <span class="comment">// 将本地邮件状态设置为已读</span></span><br><span class="line">        <span class="keyword">var</span> mailBox = _mailBoxService.Get (a =&gt; a.UniqueId == uniqueid &amp;&amp; a.OwnerMailAccount == accountId).ToArray ();</span><br><span class="line">        mailBox.Each (a =&gt; a.IsRead = <span class="literal">true</span>);</span><br><span class="line">        <span class="keyword">if</span> (_mailBoxService.UpdateRange (mailBox) &gt; <span class="number">0</span>) r = <span class="literal">true</span>;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">        <span class="keyword">throw</span> e;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> r;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;summary&gt;</span></span></span><br><span class="line"><span class="comment"><span class="doctag">///</span> 设置此邮件是对指定邮件的回复</span></span><br><span class="line"><span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;/summary&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">SetReplyTo</span> (<span class="params"><span class="keyword">uint</span> uniqueid, MimeMessage message, <span class="keyword">int</span> AccountId, <span class="keyword">string</span> folderName = <span class="literal">null</span></span>)</span> &#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        MimeMessage remail = SetMailFlag (MessageFlags.Answered, uniqueid, AccountId, folderName);</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">string</span>.IsNullOrEmpty (remail.MessageId))</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        <span class="comment">// 设置此邮件是对这个MESSAGEID的邮件的回复</span></span><br><span class="line">        message.InReplyTo = remail.MessageId;</span><br><span class="line">        <span class="comment">// 此邮件的"对其它消息"的引用属性设为这个邮件的引用属性</span></span><br><span class="line">        <span class="keyword">foreach</span> (<span class="keyword">var</span> id <span class="keyword">in</span> remail.References)</span><br><span class="line">            message.References.Add (id);</span><br><span class="line">        message.References.Add (remail.MessageId);</span><br><span class="line">        MailBoxEntity mail = _mailBoxService.Get (a =&gt; a.UniqueId == uniqueid).FirstOrDefault ();</span><br><span class="line">        mail.IsAnswered = <span class="literal">true</span>;</span><br><span class="line">        _mailBoxService.Update (mail, <span class="literal">true</span>);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">        <span class="keyword">throw</span> e;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;summary&gt;</span></span></span><br><span class="line"><span class="comment"><span class="doctag">///</span> 设置邮件已删除</span></span><br><span class="line"><span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;/summary&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">bool</span> <span class="title">SetDelted</span> (<span class="params"><span class="keyword">uint</span> uniqueid, <span class="keyword">int</span> accountId, <span class="keyword">string</span> folderName = <span class="literal">null</span></span>)</span> &#123;</span><br><span class="line">    <span class="keyword">bool</span> r = <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        SetMailFlag (MessageFlags.Deleted, uniqueid, accountId, folderName);</span><br><span class="line">        <span class="comment">// 将本地邮件状态设置为已删除</span></span><br><span class="line">        MailBoxEntity mailBox = _mailBoxService.Get (a =&gt; a.UniqueId == uniqueid &amp;&amp; a.OwnerMailAccount == accountId).FirstOrDefault ();</span><br><span class="line">        mailBox.DataStatus = (<span class="keyword">int</span>) DataStatus.Deleted;</span><br><span class="line">        <span class="keyword">if</span> (_mailBoxService.Update (mailBox) &gt; <span class="number">0</span>) r = <span class="literal">true</span>;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">        <span class="keyword">throw</span> e;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> r;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="组件使用感悟"><a href="#组件使用感悟" class="headerlink" title="组件使用感悟"></a>组件使用感悟</h2><p>MailKit和MimeKit组件在项目的使用中较为的便捷，基本包含了所有的基础邮件服务操作。组件提供的SmtpClient类提供的功能很丰富，例如连接邮件服务器，邮件账户认证，组装邮件消息，获取邮件服务器配置信息等等方法的提供，可以让我们在项目中快速的获取邮件服务的所有信息。</p>
<p>使用过邮件功能的项目 都会有困扰，客户端与邮件服务器的连接是否成功，以及邮件是否发送成功状态没有办法很快的获取，只能根据邮件服务器返回的一场状态进行判断。但是MailKit提供对应的方法和异常类，对邮件服务器返回的异常信息进行解析，客户端可以根据这些异常类获取邮件状态。</p>
<p>MailKit组件的提供了ProtocolLogger类，该类用于记录SMTP操作基础信息，该类作用为记录邮件服务日志。在邮件发送完毕后，需要及时的关闭连接，调用Disconnect(true)方法。</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;邮件服务是一般的系统都会拥有和需要的功能，但是对于.Net项目来说，邮件服务的创建和使用会较为的麻烦。.NET对于邮件功能提供了System.Net.Mail用于创建邮件服务，该基础服务提供邮件的基础操作，并且使用也较为的简单。对于真正将该功能使用于项目的人，就会慢慢发现其中的优缺点，甚至有些时候不能忍受其中的问题。在这里介绍一种微软用于替代System.Net.Mail的邮件服务组件MailKit和MimeKit，官网地址：&lt;a href=&quot;http://www.mimekit.net/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;http://www.mimekit.net/&lt;/a&gt; GitHub地址：&lt;a href=&quot;https://github.com/jstedfast/MimeKit&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://github.com/jstedfast/MimeKit&lt;/a&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="技术" scheme="VickChen.win/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="CSharp" scheme="VickChen.win/tags/CSharp/"/>
    
      <category term=".Net Core" scheme="VickChen.win/tags/Net-Core/"/>
    
      <category term="Email" scheme="VickChen.win/tags/Email/"/>
    
  </entry>
  
  <entry>
    <title>Entity Framework Core 之数据库迁移</title>
    <link href="VickChen.win/2018/201811041748/"/>
    <id>VickChen.win/2018/201811041748/</id>
    <published>2018-11-04T09:48:01.000Z</published>
    <updated>2019-07-20T08:06:36.000Z</updated>
    
    <content type="html"><![CDATA[<p>最近项目中用到了Entity Framework Core，发现网上很多文章讲的都是之前版本的用法，对于刚接触EF core的朋友来说可能有点懵。特意整理了几个细节</p>
<a id="more"></a>
<h3 id="区别"><a href="#区别" class="headerlink" title="区别"></a>区别</h3><p>首先EF CORE跟以前的EF6是有不同点的，<br>微软官网列出的不同点：[<a href="https://docs.microsoft.com/en-us/ef/efcore-and-ef6/index" target="_blank" rel="noopener">https://docs.microsoft.com/en-us/ef/efcore-and-ef6/index</a>]</p>
<h3 id="安装-EF-核心-NuGet-包"><a href="#安装-EF-核心-NuGet-包" class="headerlink" title="安装 EF 核心 NuGet 包"></a>安装 EF 核心 NuGet 包</h3><p>若要使用 EF 核心，请为你想要使用的数据库提供程序安装 NuGet 包。 例如，如果目标 SQL Server，你将安装<code>Microsoft.EntityFrameworkCore.SqlServer</code>。</p>
<p>如果你打算使用迁移，则还应安装<code>Microsoft.EntityFrameworkCore.Tools</code>包。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Install-Package Microsoft.EntityFrameworkCore.SqlServer</span><br><span class="line">Install-Package Microsoft.EntityFrameworkCore.Tools</span><br></pre></td></tr></table></figure>
<p>首先新建一个 Model 类 SysUser:</p>
<p><img src="https://raw.githubusercontent.com/VickChen1992/PicRepository/master/9460f058gy1fww6nzsgi5j20l60gnq3i.jpg" alt></p>
<p> 然后建立EFCoreContext类:</p>
<p><img src="https://raw.githubusercontent.com/VickChen1992/PicRepository/master/9460f058gy1fww6nyoge5j20oq0cddga.jpg" alt></p>
<p>自动创建数据库:</p>
<p><img src="https://raw.githubusercontent.com/VickChen1992/PicRepository/master/9460f058gy1fww6nzlzg4j20l30cijrv.jpg" alt></p>
<p>此时我们的数据库和数据都已经有了:</p>
<p><img src="https://raw.githubusercontent.com/VickChen1992/PicRepository/master/9460f058gy1fww6nzlsmhj20e407wglu.jpg" alt></p>
<h3 id="数据迁移"><a href="#数据迁移" class="headerlink" title="数据迁移"></a>数据迁移</h3><p>此时重点来了，当我们已经有数据库表的时候，我们需要修改字段，如何进行迁移?</p>
<p>首先打开VS-&gt;工具-&gt;NuGet包管理器-&gt;程序包管理控制台</p>
<p>输入命令：<code>Add-Migration init</code>（执行此命令项目生成一个目录<migration>）</migration></p>
<p><img src="https://raw.githubusercontent.com/VickChen1992/PicRepository/master/9460f058gy1fww6o0e4lgj20sq08vmxu.jpg" alt></p>
<p>我们会发现Model程序集下多了一个文件夹为Migrations里面有3个文件.如下:</p>
<p><img src="https://raw.githubusercontent.com/VickChen1992/PicRepository/master/9460f058gy1fww6ny8zauj208e021743.jpg" alt></p>
<p>xxxxxxx_init.cs主迁移文件。包含应用迁移（in Up()）和恢复（in Down()）所需的操作。</p>
<p>xxxxxxx_init.Designer.cs - 迁移元数据文件。包含EF使用的信息。</p>
<p>EFCoreContextModelSnapshot.cs - 当前模型的快照。主要用于确定添加下一次迁移时发生了哪些变化.</p>
<p>然后我们执行命令: <code>Update-Database</code></p>
<p>如果你的数据库没创建,是第一次,就会执行成功。如果你前期创建过数据库.但是是第一次创建迁移，就会提示我们的表结构已经存在了。</p>
<p>我们看看xxxxxx_init.cs文件：</p>
<p><img src="https://raw.githubusercontent.com/VickChen1992/PicRepository/master/9460f058gy1fww6o0qqmmj20wj0g7wfc.jpg" alt></p>
<p>可以看到，这里第一次生成的迁移方法是按照新增来迁移的..而不是修改。</p>
<p>我们把<code>Up()</code>  <code>Down()</code>里面的代码删掉</p>
<p><img src="https://raw.githubusercontent.com/VickChen1992/PicRepository/master/9460f058gy1fww6nyzk0kj20il06t749.jpg" alt></p>
<p>这样就相当于 本次的迁移，没有做任何操作。</p>
<p>然后我们来创建真正的迁移版本：</p>
<p>首先添加一个Email字段,然后把UserName的长度改为60</p>
<p><img src="https://raw.githubusercontent.com/VickChen1992/PicRepository/master/9460f058gy1fww6o0ztg0j20kj0fwaak.jpg" alt></p>
<p>然后我们开始迁移：</p>
<p><code>Add-Migration  x2</code> （这里是迁移版本名称，可自定义，可以根据版本回滚）</p>
<p>成功创建迁移文件之后,我们更新数据库.</p>
<p><code>Update-Database x2</code></p>
<p>然后Email字段加上了，UserName长度也修改了，UserName的数据也还在。</p>
<p><img src="https://raw.githubusercontent.com/VickChen1992/PicRepository/master/9460f058gy1fww6og0hvoj20if08a74k.jpg" alt></p>
<h3 id="删除迁移"><a href="#删除迁移" class="headerlink" title="删除迁移"></a>删除迁移</h3><p>有的时候我们刚刚创建了一个迁移,还没应用到数据库,就发现自己需要变更实体.那我们就可以删除这个没有应用的迁移版本.</p>
<p>执行命令:<code>Remove-Migration</code></p>
<p><em>注意,这里是没有应用过的迁移,可以删除.如果应用过了.则会收到错误信息</em></p>
<h3 id="迁移回滚"><a href="#迁移回滚" class="headerlink" title="迁移回滚"></a>迁移回滚</h3><p>有些时候,我们需要回滚到之前的一个迁移版本.,比如我们部署的时候,开发版本和稳定版本肯定不一样..</p>
<p>那么我们就会用到回滚命令.</p>
<p>执行如下: </p>
<p><code>Update-Database</code>  这里填写需要回滚的版本名称</p>
<p>我们执行  <code>Update-Database</code>   这里填写需要回滚的版本名称</p>
<p>然后我们会发现, x2中的长度已经回到30了，Email字段也没有了….</p>
<p><img src="https://raw.githubusercontent.com/VickChen1992/PicRepository/master/9460f058gy1fww6og11llj20j9093q39.jpg" alt></p>
<h3 id="生成迁移SQL"><a href="#生成迁移SQL" class="headerlink" title="生成迁移SQL"></a>生成迁移SQL</h3><p>有的时候,我们的生产数据库,是需要用脚本来创建库的.所以我们也可以直接通过实体来生成SQL脚本.命令如下:</p>
<p><code>Script-Migration</code></p>
<p><img src="https://raw.githubusercontent.com/VickChen1992/PicRepository/master/9460f058gy1fww6ogsrvrj20yz0mrmz0.jpg" alt></p>
<p>举一反三：<code>Script-Migration x2</code>  这个脚本可以自定义需要迁移的版本号、文件名、需要生成迁移脚本的上下文</p>
<p><em>原文地址：<a href="https://www.cnblogs.com/shumin/p/8877297.html" target="_blank" rel="noopener">https://www.cnblogs.com/shumin/p/8877297.html</a></em></p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;最近项目中用到了Entity Framework Core，发现网上很多文章讲的都是之前版本的用法，对于刚接触EF core的朋友来说可能有点懵。特意整理了几个细节&lt;/p&gt;
    
    </summary>
    
      <category term="技术" scheme="VickChen.win/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="CSharp" scheme="VickChen.win/tags/CSharp/"/>
    
      <category term=".Net Core" scheme="VickChen.win/tags/Net-Core/"/>
    
      <category term="Entity Framework" scheme="VickChen.win/tags/Entity-Framework/"/>
    
  </entry>
  
  <entry>
    <title>Redis 用户验证</title>
    <link href="VickChen.win/2018/201810202143/"/>
    <id>VickChen.win/2018/201810202143/</id>
    <published>2018-10-20T13:43:31.000Z</published>
    <updated>2019-07-26T03:43:13.000Z</updated>
    
    <content type="html"><![CDATA[<p> redis没有实现访问控制这个功能，但是它提供了一个轻量级的认证方式，可以编辑redis.conf配置来启用认证。</p>
<a id="more"></a>
<h3 id="初始化Redis密码"><a href="#初始化Redis密码" class="headerlink" title="初始化Redis密码"></a>初始化Redis密码</h3><p>在配置文件中有个参数： <code>requirepass</code>  这个就是配置redis访问密码的参数。</p>
<p>比如 <code>requirepass test123</code> <strong>需重启Redis才能生效</strong></p>
<p>redis的查询速度是非常快的，外部用户一秒内可以尝试多达150K个密码。</p>
<p>所以密码要尽量长（对于DBA 没有必要必须记住密码）。</p>
<h3 id="不重启Redis设置密码"><a href="#不重启Redis设置密码" class="headerlink" title="不重启Redis设置密码"></a>不重启Redis设置密码</h3><p>在配置文件中配置<code>requirepass</code>的密码（当redis重启时密码依然有效）。<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">redis 127.0.0.1:6379&gt; config <span class="built_in">set</span> requirepass test123</span><br></pre></td></tr></table></figure></p>
<p>查询密码：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">redis 127.0.0.1:6379&gt; config get requirepass</span><br><span class="line">(error) ERR operation not permitted</span><br></pre></td></tr></table></figure></p>
<p>密码验证：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">redis 127.0.0.1:6379&gt; auth test123</span><br><span class="line">OK</span><br></pre></td></tr></table></figure></p>
<p>再次查询：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">redis 127.0.0.1:6379&gt; config get requirepass</span><br><span class="line">1) <span class="string">"requirepass"</span></span><br><span class="line">2) <span class="string">"test123"</span></span><br></pre></td></tr></table></figure></p>
<p><strong>如果配置文件中没添加密码，密码会在redis重启后失效</strong></p>
<h3 id="登陆有密码的Redis"><a href="#登陆有密码的Redis" class="headerlink" title="登陆有密码的Redis"></a>登陆有密码的Redis</h3><p>在登录的时候的时候输入密码：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">redis-cli -p 6379 -a test123</span><br></pre></td></tr></table></figure></p>
<p>先登陆后验证：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">redis-cli -p 6379</span><br><span class="line">redis 127.0.0.1:6379&gt; auth test123</span><br><span class="line">OK</span><br></pre></td></tr></table></figure>
<p>AUTH命令跟其他redis命令一样，是没有加密的，阻止不了攻击者在网络上窃取你的密码。</p>
<p>认证层的目标是提供多一层的保护，如果防火墙或者用来保护redis的系统防御失败的话，外部用户如果没有通过密码认证还是无法访问redis的。</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt; redis没有实现访问控制这个功能，但是它提供了一个轻量级的认证方式，可以编辑redis.conf配置来启用认证。&lt;/p&gt;
    
    </summary>
    
      <category term="技术" scheme="VickChen.win/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="Linux" scheme="VickChen.win/tags/Linux/"/>
    
      <category term="Redis" scheme="VickChen.win/tags/Redis/"/>
    
  </entry>
  
</feed>
